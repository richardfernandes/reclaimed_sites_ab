---
title: "Negative buffers and pixel count"
format: html
---

File to fix for documentation about creating buffers. 

The first section is working with files locally and with python tools only.
The second sections is the same process but in GEE

```{python}
# Imports
import fiona
import geopandas as gpd
import pandas as pd
import os
import sys
import janitor
import matplotlib.pyplot as plt

# Read data
sys.path.append(os.path.abspath(os.path.join('..')))

data_directory = os.path.join(sys.path[-1], 'data/HFI2021.gdb/HFI2021.gdb')

fiona.listlayers(data_directory)

abandoned_wells = gpd.read_file(data_directory,
                                driver = 'FileGDB',
                                layer = 'o16_WellsAbnd_HFI_2021')
```

# Test buffer function in 1 polygon

## Square polygon
```{python}
one_test = abandoned_wells.iloc[:1]

one_test.plot()

one_test_buffer = one_test['geometry'].buffer(-30)
one_test_buffer.plot()
```

## Not square polygon
```{python}
one_test_buffer = one_test.copy()
one_test_buffer['geometry'] = one_test_buffer['geometry'].buffer(-30)

# Create a plot
fig, ax = plt.subplots()

# Plot the original polygon
one_test.plot(ax=ax, color='blue', edgecolor='black', alpha=0.5)

# Plot the buffered polygon
one_test_buffer.plot(ax=ax, color='red', edgecolor='black', alpha=0.5)

# Add a legend
legend_elements = [plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='blue', markersize=10, label='Original Polygon'),
                   plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='red', markersize=10, label='Buffered Polygon')]
ax.legend(handles=legend_elements)

# Display the plot
plt.show()
```


```{python}
second_test = abandoned_wells[abandoned_wells['WELLSITE_FOOTPRINT_ID'] == 149236.0]

second_test_buffer = second_test.copy()
second_test_buffer['geometry'] = second_test_buffer['geometry'].buffer(-30, 1)

fig, ax = plt.subplots()

second_test.plot(ax = ax, color = 'blue', edgecolor = 'black', alpha = 0.5)
second_test_buffer.plot(ax = ax, color = 'red', edgecolor = 'black', alpha = 0.5)

plt.show()
```

## Trying to export results

This is not working, results loose the CRS
```{python}
# Check negative buffers
original_test = abandoned_wells.iloc[:100]

test = original_test.copy()

buffer_geometries = test['geometry'].buffer(-30)
buffer_gdf = gpd.GeoDataFrame(test.drop(columns='geometry'), geometry=buffer_geometries)
buffer_gdf = buffer_gdf.drop(columns='FIRST_SPUD_DATE')
test.to_file("buffers_gdf.shp", driver='ESRI Shapefile')


# import ee

# ee.Initialize() 

# # Convert the GeoDataFrame to an Earth Engine FeatureCollection
# ee_fc = ee.FeatureCollection(buffer_gdf.__geo_interface__)

# # Export the FeatureCollection to an Asset in GEE
# export_asset_id = 'projects/ee-ronnyale/assets/test_buffer'  # Change to your desired asset path
# export_task = ee.batch.Export.table.toAsset(
#     collection=ee_fc,
#     description='export_test_buffers',
#     assetId=export_asset_id
# )
# export_task.start()


# # Export the result with roads+residential+industrial
# export_asset_id = 'projects/ee-ronnyale/assets/test_buffer'
# export_task = ee.batch.Export.table.toAsset(
#     collection=buffer_gdf,
#     description='export_test_buffers',
#     assetId=export_asset_id
# )
# export_task.start()
```


```{python}
from ipyleaflet import Map, GeoData, basemaps, LayersControl
import geopandas as gpd

original_test = abandoned_wells.iloc[:100]

buffer_geometries = original_test["geometry"].buffer(30)

buffer_gdf = gpd.GeoDataFrame(
    original_test.drop(columns="geometry"), geometry=buffer_geometries
)
buffer_gdf = buffer_gdf.drop(columns="FIRST_SPUD_DATE")

m = Map(
    center=[
        buffer_gdf.geometry.iloc[0].centroid.y,
        buffer_gdf.geometry.iloc[0].centroid.x,
    ],
    zoom=10,
    basemap=basemaps.OpenStreetMap.Mapnik,
)

geo_data = GeoData(geo_dataframe=buffer_gdf, name="Buffers")
m.add_layer(geo_data)
m.add_control(LayersControl())
m
```

# GEE

```{python}
import ee
ee.Initialize()

feature_collection = ee.FeatureCollection(
    "projects/ee-ronnyale/assets/intersecting_wells_flags_v4"
)

# Function to apply inward buffer to each feature
def apply_inward_dilation(feature):
    buffered_feature = feature.buffer(-30, 1)
    # dilated_feature = feature.difference(buffered_feature)
    return buffered_feature
    # return dilated_feature

# Apply the function to each feature in the collection
dilated_abandoned_wells = feature_collection.map(apply_inward_dilation)

import folium
import geemap

Map = geemap.Map(center=[53.516, -113.498], zoom=5)
Map.addLayer(feature_collection, {"color": "blue"}, "Original FeatureCollection")
Map.addLayer(dilated_abandoned_wells, {"color": "red"}, "Dilated FeatureCollection")
Map
```

So, from here I can
```{python}
results = dilated_abandoned_wells.limit(2).getInfo()
print('Updated Abandoned Wells:', json.dumps(results, indent=2))
```

Probably there are features without geometries after the negative buffer. We can try to check this.

```{python}
def check_empty_coordinates(feature):
    coordinates = feature.geometry().coordinates()
    is_empty = coordinates.size().eq(0)
    return feature.set('empty_buffer', is_empty)

check_empty_dilated = dilated_abandoned_wells.map(check_empty_coordinates)
results = check_empty_dilated.limit(2).getInfo()
print(json.dumps(results, indent = 2))
```

That chunk before is working. Now, probably I will have to export it as an asset and then do
something with the ones that are empty. Actually, the problem will persist because no empty
geometries can be exported. The difference in here is that the result just contains the geometry
of the buffer and not the original polygon (as far as I can see)

I will have to try to run the filter:

```{python}
run_filter = check_empty_dilated.filter(ee.Filter.eq('empty_buffer', 1))
# total = run_filter.size()
# print(total) 
results = run_filter.limit(2).getInfo()
print(json.dumps(results, indent = 2))
```


IT WORKS! The filter didn't get stuck! Now, having the 


Let's check some features characteristics comparing the original feature collection and
the dilated collection.

```{python}
collection_size = feature_collection.size().getInfo()
print(f"Feature collection size: {collection_size}")

collection_size = dilated_abandoned_wells.size().getInfo()
print(f"Dilated abandoned wells size: {collection_size}")

collection_bounds = feature_collection.geometry().bounds().getInfo()
print(f"Collection bounds: {collection_bounds}")

collection_bounds = dilated_abandoned_wells.geometry().bounds().getInfo()
print(f"Dilated abandoned wells bounds: {collection_bounds}")
```

This one almost run, but nonetheless, it looks like all the features have a geometry.
```{python}
# Function to add a property indicating whether geometry exists
def add_geometry_exists_property(feature):
    return feature.set('hasGeometry', feature.geometry().geometries().size().gt(0))

# Apply the function to each feature in the collection
features_with_geometry = feature_collection.map(add_geometry_exists_property)

results = features_with_geometry.limit(2).getInfo()
print(json.dumps(results, indent = 2))

# Filter out features with empty geometries
filtered_features = features_with_geometry.filter(ee.Filter.eq('hasGeometry', 0))

results = filtered_features.limit(2).getInfo()
print(json.dumps(results, indent = 2))

# Count the number of features with empty geometries
empty_geometry_count = features_with_geometry.size().subtract(filtered_features.size()).getInfo()

print(f"Number of features with empty geometries: {empty_geometry_count}")
```

Probably, to avoid problems with geometries, it will be better to run the negative buffer, 
count the number of pixels, and then pass the number of pixels to the original asset.


```{python}
# Define the asset ID
asset = "projects/ee-ronnyale/assets/intersecting_wells_flags_v2"

# Load the feature collection
feature_collection = ee.FeatureCollection(asset)

# Function to apply inward buffer to each feature
def apply_inward_dilation(feature):
    buffered_feature = feature.buffer(-30, 1)
    return ee.Feature(buffered_feature).copyProperties(feature)

# Apply the function to each feature in the collection
dilated_abandoned_wells = feature_collection.map(apply_inward_dilation)

# Filter out any features with empty geometries (optional but recommended)
dilated_abandoned_wells = dilated_abandoned_wells.filter(ee.Filter.geometry())

# Create a constant image to count pixels
pixels = (
    ee.Image.constant(1)
    .clip(dilated_abandoned_wells)
    .rename("pixels")
    .reproject(
        crs="EPSG:32512",  # UTM zone 12N
        scale=30,
    )
)

# Reduce regions to count pixels within each polygon
pixel_count = pixels.reduceRegions(
    collection=dilated_abandoned_wells, reducer=ee.Reducer.count(), scale=30
)

# Function to add the pixel count to the original feature
def add_pixel_count(original_feature):
    well_id = original_feature.get('WELLSITE_FOOTPRINT_ID')  # Assuming this is the unique ID
    matching_count_feature = pixel_count.filter(ee.Filter.eq('WELLSITE_FOOTPRINT_ID', well_id)).first()
    pixel_count_value = ee.Number(matching_count_feature.get('count')).int()
    return original_feature.set('pixel_count', pixel_count_value)

# Map the function over the original feature collection
updated_feature_collection = feature_collection.map(add_pixel_count)

# # Export the updated feature collection
# export_asset_id = 'projects/ee-ronnyale/assets/intersecting_wells_flags_v3_with_pixel_count'
# export_task = ee.batch.Export.table.toAsset(
#     collection=updated_feature_collection,
#     description='export_intersecting_wells_flags_v3_with_pixel_count',
#     assetId=export_asset_id
# )
# export_task.start()

# print("Export task started.")

```


Before doing the above, probably its happening that in the smallest polygons there is no way to create a
negative buffer. But, what comes out after the operation?


```{python}
test = dilated_abandoned_wells.filter(ee.Filter.eq('wllst__', 287438))
results = test.limit(2).getInfo()
print(json.dumps(results, indent  = 2))

print(test.getInfo())
```