---
title: "GEE polygons filters"
author: Ronny A. Hernandez Mora
execute:
  message: false
  warning: false
format: 
  html:
    theme:
      - flatly
    linkcolor: "#FF5500"
    highlight-style: tango
    toc: true
    toc-title: Table of contents
    toc-location: left
    number-sections: false
    colorlinks: true
    code-fold: true
    code-line-numbers: true
editor: visual
jupyter: python3
editor_options: 
  chunk_output_type: console
---

```{python}
import ee
import geemap
import folium
```

After selecting the polygons from the abandoned wells, the following steps will continue with the 
filtering in GEE.

# Abandoned wells polygons

Polygons data source is the the layer `o16_WellsAbnd_HFI_2021` from the [Wall-to-Wall Human Footprint Inventory](https://abmi.ca/home/data-analytics/da-top/da-product-overview/Human-Footprint-Products/HF-inventory.html) by the [Alberta Biodiversity Monitoring Institute](https://abmi.ca/home.html).

The polygons in the data are the result of the filter applied in the `run_polygons_filter.py` 
[script](https://github.com/ronnyhdez/reclaimed_sites_ab/blob/main/scripts/abandoned_sites_ingestion.py)


```{python}
# # Get list of assets

# ee.Initialize()
# path = 'users/ronnyale'

# # List assets
# assets = ee.data.listAssets({'parent': path})
# print(assets)
# # Extract asset names
# asset_names = [asset['id'] for asset in assets['assets']]

# # Print the asset names
# print("List of assets:")
# for asset in asset_names:
#     print(asset)
```


```{python}
ee.Initialize()

asset_id = 'projects/ee-ronnyale/assets/selected_polygons'

abandoned_wells = ee.FeatureCollection(asset_id)

# getInfo query is aborted after accumulating 5000 elements
# print(abandoned_wells.getInfo())
```

Check the polygons

```{python}
Map = geemap.Map(center=[53.516, -113.498], zoom=5)
Map.addLayer(abandoned_wells, {}, "Polygons")
Map
```

# Reservoirs 

The reservoirs polygons data source is the the layer `o01_Reservoirs_HFI_2021` from the [Wall-to-Wall Human Footprint Inventory](https://abmi.ca/home/data-analytics/da-top/da-product-overview/Human-Footprint-Products/HF-inventory.html) by the [Alberta Biodiversity Monitoring Institute](https://abmi.ca/home.html).

According to the _HFI 2021 Metadata, Version 1.0_, reservoirs are:

 > An artificial lake or storage pond resulting from human-made dam.
 A body of water created by excavation or the man-made damming of a
 river or stream.

```{python}
asset_id = 'projects/ee-ronnyale/assets/reservoirs'
reservoirs = ee.FeatureCollection(asset_id)

Map.addLayer(reservoirs, {'color': 'blue'}, 'Reservoirs')
Map
```

## Create buffers in Reservoirs polygons

```{python}
# Create function to buffer each feature by 30m
def buffer_feature(feature):
  return feature.buffer(30)

# Apply the buffer function to each of the reservoir polygons
buffered_reservoirs = reservoirs.map(buffer_feature)
```

Let's check the buffered reservoirs

```{python}
Map.addLayer(buffered_reservoirs, {}, "Buffered Reservoirs")
Map
```

### Check intersections

Manually, it seems that there is no abandoned well that intersects the reservoirs buffer areas.
Nonethels, we can check this with a function.

```{python}
# Function to find intersections between buffered polygons and waterbodies
def find_intersections(feature):
    intersection = abandoned_wells.filterBounds(feature.geometry())
    return ee.Feature(intersection.geometry(), feature.toDictionary())

# Map the intersection function over the buffered polygons
intersections = buffered_reservoirs.map(find_intersections)

# Filter out empty geometries
intersections = intersections.filter(ee.Filter.notNull(['geometry']))

# Display the map
Map.addLayer(intersections, {'color': 'yellow'}, "Intersecting Polygons")
Map
```

# Waterbodies

Using the _Land-use/Land-cover Classification of Alberta, Derived from 2020 Sentinel-2 Multispectral Data_ [here](https://ags.aer.ca/publication/dig-2021-0019), it's based on reflectance data.

I need to reduce the image to obtain polgyons according to the category `1` which is `Water`. 

Let's check the asset info:

```{python}
asset_id = 'projects/ee-eoagsaer/assets/LULC_2022_EE'

asset_image = ee.Image(asset_id)

info = asset_image.getInfo()
print(info)
# print("Asset Type:", info['type'])
# print("Bands:", info['bands'])
# print("Properties:", info['properties'])
```


## The Land Cover Classification layer

The asset we consumed from GEE, looks like:

```{python}
land_cover_viz = {
    'min': 0,
    'max': 14,
    'palette': [
        '000000',  
        '1f77b4',  
        'ff7f0e',  
        '2ca02c',  
        'd62728',  
        '9467bd',  
        '8c564b',  
        'e377c2',  
        '7f7f7f',  
        'bcbd22',  
        '17becf',  
        '8c564b',  
        'e377c2',  
        '7f7f7f',   
        '7f7f72'   
    ]
}

Map.addLayer(asset_image, 
            land_cover_viz,
            'land cover')
Map
```

## Get just the waterbodies mask

```{python}
water_mask = asset_image.eq(1)
water_image = asset_image.updateMask(water_mask)
```

After getting the waterbodies mask, we need to reduce the raster to a vector

```{python}
water_bodies_vector = water_image.reduceToVectors(
    geometryType='polygon',
    scale=10,  # LCC layer documentation states is 10m
    maxPixels=1e8,
    bestEffort=True,
    labelProperty='water_bodies'
)
```

We can check the waterbodies mask:

```{python}
Map.addLayer(water_bodies_vector, {'color': 'blue'}, 'water bodies' )
Map
```


```{python}
print(water_bodies_vector.size().getInfo())  # Number of water body polygons
# print(water_bodies_vector.getInfo()) # Query exceeds the API limit
```


```{python}
export_task = ee.batch.Export.table.toDrive(
    collection=water_bodies_vector,
    description='WaterBodiesPolygons',
    folder='EarthEngineExports',
    fileFormat='SHP'
)
export_task.start()
print("Export started. Check your Google Drive for the results.")
```