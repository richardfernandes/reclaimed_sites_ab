[
  {
    "objectID": "notebooks/leaf_process.html",
    "href": "notebooks/leaf_process.html",
    "title": "Process one site with LEAF-toolbox",
    "section": "",
    "text": "import ee\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport os\nimport sys"
  },
  {
    "objectID": "notebooks/leaf_process.html#imports",
    "href": "notebooks/leaf_process.html#imports",
    "title": "Process one site with LEAF-toolbox",
    "section": "",
    "text": "import ee\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport os\nimport sys"
  },
  {
    "objectID": "notebooks/leaf_process.html#gee-authentication",
    "href": "notebooks/leaf_process.html#gee-authentication",
    "title": "Process one site with LEAF-toolbox",
    "section": "GEE authentication",
    "text": "GEE authentication\n\nee.Authenticate()\nee.Initialize()\n\nTest if authentication was successful\n\nprint(ee.String('Hello from the Earth Engine servers!').getInfo())\n\nHello from the Earth Engine servers!"
  },
  {
    "objectID": "notebooks/leaf_process.html#leaf-toolbox-imports",
    "href": "notebooks/leaf_process.html#leaf-toolbox-imports",
    "title": "Process one site with LEAF-toolbox",
    "section": "LEAF-toolbox imports",
    "text": "LEAF-toolbox imports\nModules imports cannot be done before GEE authentication have been run succesfuly\n\n# Add the parent directory of leaftoolbox to the system path\nmodule_path = os.path.abspath(os.path.join('..'))\nif module_path not in sys.path:\n    sys.path.append(module_path)\n    \nfrom leaftoolbox import LEAF\nfrom leaftoolbox import SL2PV0 \nfrom leaftoolbox import SL2PV1\n\n/home/ronny/.local/share/virtualenvs/reclaimed_sites_ab-QXta-KJo/lib/python3.10/site-packages/ee/deprecation.py:202: DeprecationWarning:\n\n\n\nAttention required for JRC/GSW1_0/GlobalSurfaceWater! You are using a deprecated asset.\nTo ensure continued functionality, please update it.\nLearn more: https://developers.google.com/earth-engine/datasets/catalog/JRC_GSW1_0_GlobalSurfaceWater"
  },
  {
    "objectID": "notebooks/abandoned_wells.html",
    "href": "notebooks/abandoned_wells.html",
    "title": "Abandoned wells data exploration",
    "section": "",
    "text": "This is an Exploratory Data Analysis to understand the data characteristics of the layer o16_WellsAbnd_HFI_2021 from the Wall-to-Wall Human Footprint Inventory by the Alberta Biodiversity Monitoring Institute.\nThe aim is to identify characteristics that may aid in selecting polygons for subsequent analysis.\nFor the findings summary, go to Key findings"
  },
  {
    "objectID": "notebooks/abandoned_wells.html#unique-values-per-variable",
    "href": "notebooks/abandoned_wells.html#unique-values-per-variable",
    "title": "Abandoned wells data exploration",
    "section": "Unique values per variable",
    "text": "Unique values per variable\nHow many unique values do we have per variable?\n\n\nCode\nabandoned_wells_df |&gt; \n        map_dfr(~n_distinct(.x)) |&gt; \n        paged_table()\n\n\n\n\n  \n\n\n\nInsights from the output:\n\nfootprint_id does not match the number of observations. Check if there are NA’s in polygons and why.\nwell_status we just have 1 which means abandoned.\nspud_date and spud_year are the date when drilling first began on the well pad. 125 different years in the registry? Check how many years of data we have.\nThe number_wellheads is the total number of wellbores on the well pad. Does this have an impact in the reclamation process?\nvisible variable probably have NA's. There should be just 3 values: 0 = not visible, 1 = fully visible, 2 = partially visible. This reflects the state of visibility of a footprint. No idea what this means.\noilsands_evaluation_well we have just the 2 categories described in documentation: 0 = No Oil Sands Evaluation (OSE) well, 1 = OSE well present.\nCheck distribution of variable reclamation_status.\nreclamation_date it’s the most recent reclamation certification."
  },
  {
    "objectID": "notebooks/abandoned_wells.html#key-variable",
    "href": "notebooks/abandoned_wells.html#key-variable",
    "title": "Abandoned wells data exploration",
    "section": "Key variable",
    "text": "Key variable\nWhat is each row? The dataset has 182189 observations that should match the same amount of unique values for one of the variables contained in the dataset. The variable closer to this number is footprint_id, but it has less number of unique values. What are they?\nAssuming that each row in the dataset is one unique site (or one unique observation), the wellsite_footprint_id should have one observation per each id.\nWhen grouping all the observations per wellsite_footprint_id, I found those id’s that have more than 1 observation as shown in Table 1.\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(wellsite_footprint_id) |&gt; \n        tally(sort = T) |&gt; \n        filter(n &gt; 1) |&gt; \n        gt()\n\n\n\n\n\n\nTable 1:  Well site id’s with more than 1 observation \n  \n    \n      wellsite_footprint_id\n      n\n    \n  \n  \n    NA\n1001\n    109118\n3\n    109503\n3\n    268598\n2\n    287438\n2\n    305376\n2\n    313410\n2\n    317515\n2\n    319334\n2\n    320068\n2\n    320225\n2\n    320312\n2\n    321608\n2\n    323037\n2\n    323334\n2\n    323467\n2\n    324441\n2\n    324474\n2\n    324597\n2\n    324936\n2\n    325167\n2\n    325895\n2\n    326530\n2\n    326601\n2\n    326972\n2\n    327070\n2\n    328678\n2\n    345923\n2\n  \n  \n  \n\n\n\n\n\nThe Table 2, shows every well site with more than 1 observation per id. In total, there are 56 well sites with this condition, excluding the observations with NAs. It seems to have the same values for each of its variables except for the shape_length and shape_area.\n\n\nCode\nrepeated_ids &lt;- abandoned_wells_df |&gt; \n        group_by(wellsite_footprint_id) |&gt; \n        tally() |&gt; \n        filter(n &gt; 1 & !is.na(wellsite_footprint_id)) |&gt; \n        select(wellsite_footprint_id) |&gt; \n        pull()\n\nabandoned_wells_df |&gt; \n        filter(wellsite_footprint_id %in% repeated_ids) |&gt; \n        arrange(wellsite_footprint_id) |&gt; \n        paged_table()\n\n\n\n\n Table 2:  Data frame subset of the well sites which have more than 1\nobservation per id \n  \n\n\n\n\nThe Figure 1 plots of the observations with the same id shows that probably, some well sites, are composed by more than 1 polygon. They look relatively close. This segmentation explains the differences in the shape_length and shape_area variables when the rest of the variables are the exact same per id\n\n\nCode\na &lt;- abandoned_wells |&gt; \n        filter(wellsite_footprint_id == 109118) |&gt; \n        ggplot() +\n        geom_sf() \n\nb &lt;- abandoned_wells |&gt; \n        filter(wellsite_footprint_id == 109503) |&gt; \n        ggplot() +\n        geom_sf()\n\nc &lt;- abandoned_wells |&gt; \n        filter(wellsite_footprint_id == 268598) |&gt; \n        ggplot() +\n        geom_sf()\n\nd &lt;- abandoned_wells |&gt; \n        filter(wellsite_footprint_id == 287438) |&gt; \n        ggplot() +\n        geom_sf()\n\nplot_grid(a, b, c, d, labels = c('A', 'B', 'C', 'D'))\n\n\n\n\n\nFigure 1: Polygons with the same well site id\n\n\n\n\n\nWhat is happening with the NA’s in id?\nThere are 1001 observations which have NA in the wellsite_footprint_id variable. The Figure 2 shows that together with the wellsite_footprint_id, the disp_num, lcu_id, and the vast majority of fieldname observations are also NAs.\n\n\nCode\nabandoned_wells_df |&gt; \n        filter(is.na(wellsite_footprint_id) == TRUE) |&gt; \n        vis_dat(sort_type = F)\n\n\n\n\n\nFigure 2: Observations with NA in the well site id variable\n\n\n\n\nPolygons with NA’s in their ids seems to be fine (not segmented or empty). The Figure 3 shows two of them.\n\n\nCode\na &lt;- abandoned_wells |&gt; \n        filter(is.na(wellsite_footprint_id) == TRUE) |&gt; \n        slice(34) |&gt; \n        ggplot() +\n        geom_sf() \n\nb &lt;- abandoned_wells |&gt; \n        filter(is.na(wellsite_footprint_id) == TRUE) |&gt; \n        slice(534) |&gt; \n        ggplot() +\n        geom_sf() \n\nplot_grid(a, b, labels = c('A', 'B'))\n\n\n\n\n\nFigure 3: Polygons with NAs in their ids\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThere are 27 “segmented polygons” which are represented by the same id. Also we have 1001 NA’s in the well site ids, which have at the same time NAs in disp_num, lcu_id, and fieldname\nShould we exclude the 56 segmented polygons? Do we want to use polygons without any id?"
  },
  {
    "objectID": "notebooks/abandoned_wells.html#character-variables",
    "href": "notebooks/abandoned_wells.html#character-variables",
    "title": "Abandoned wells data exploration",
    "section": "Character variables",
    "text": "Character variables\nWe have just 6 character variables. Nonetheless, I should take into account that other variables with categories are encoded with numbers and I should check the ABMI data document to understand the meaning. The table ?@tbl-character_variables\n\n\nCode\nabandoned_wells_df |&gt; \n        select_if(is.character) |&gt; \n        glimpse() \n\n\n\n?(caption)\n\n\n\nRows: 182,189\nColumns: 7\n$ disp_num           &lt;chr&gt; \"MSL974346\", NA, NA, \"MSL920658\", NA, NA, NA, NA, N…\n$ lcu_id             &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ reclamation_status &lt;chr&gt; \"not_reclaimed\", \"not_reclaimed\", \"reclaimed\", \"not…\n$ fieldname          &lt;chr&gt; NA, \"ATHABASCA Oil Sands\", \"ATHABASCA Oil Sands\", N…\n$ feature_ty         &lt;chr&gt; \"WELL-ABAND\", \"WELL-ABAND\", \"WELL-ABAND\", \"WELL-ABA…\n$ source             &lt;chr&gt; \"AHFMP\", \"AHFMP\", \"AHFMP\", \"AHFMP\", \"AHFMP\", \"AHFMP…\n$ hfi_id             &lt;chr&gt; \"{4F2CC0D4-6909-433C-A609-2F7AD77AEDA0}\", \"{018C1EC…\n\n\n\n\nCheck unique values per character variable:\n\n\nCode\n# Check number of distinct observations\nabandoned_wells_df |&gt; \n        select_if(is.character) |&gt; \n        map(~n_distinct(.x))\n\n\n$disp_num\n[1] 36124\n\n$lcu_id\n[1] 1050\n\n$reclamation_status\n[1] 3\n\n$fieldname\n[1] 4\n\n$feature_ty\n[1] 1\n\n$source\n[1] 4\n\n$hfi_id\n[1] 182142\n\n\nCode\n# Check categories \nabandoned_wells_df |&gt; \n        select_if(is.character) |&gt; \n        select(-hfi_id, -disp_num, -lcu_id) |&gt;\n        map(~unique(.x))\n\n\n$reclamation_status\n[1] \"not_reclaimed\"      \"reclaimed\"          \"reclamation_exempt\"\n\n$fieldname\n[1] NA                      \"ATHABASCA Oil Sands\"   \"COLD LAKE Oil Sands\"  \n[4] \"PEACE RIVER Oil Sands\"\n\n$feature_ty\n[1] \"WELL-ABAND\"\n\n$source\n[1] \"AHFMP\"  \"ABMI21\" \"ABMI19\" \"ABMI\"  \n\n\n\n\nCode\n# abandoned_wells_df |&gt; \n#         vis_dat(warn_large_data = FALSE)\n\n\n\n\n\n\n\n\nNote\n\n\n\nEverything seems fine with the character variables. Not much information seems to be useful for the analysis.\nThere is just the category abandoned, 3 fieldnames and 4 data sources"
  },
  {
    "objectID": "notebooks/abandoned_wells.html#reclamation-date",
    "href": "notebooks/abandoned_wells.html#reclamation-date",
    "title": "Abandoned wells data exploration",
    "section": "Reclamation date",
    "text": "Reclamation date\nWe need to obtain the latest reclamation date for each of the polygons. One site could potentially have several reclamation dates, but we have no way to find out that information from this dataset. Also we are considering using just the last reclamation date for the analysis. This dataset has reclamation dates that span 0, 2022.\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(reclamation_date) |&gt; \n        tally() |&gt; \n        paged_table()\n\n\n\n\n  \n\n\n\nCode\nzero_obs &lt;- abandoned_wells_df |&gt; \n        group_by(reclamation_date) |&gt; \n        tally() |&gt; \n        filter(reclamation_date == 0) |&gt; \n        select(n) |&gt; \n        pull()\n\n\n\n\n\n\n\n\nImportant\n\n\n\nFrom the summarized table, there are 89915 observations with a year reclamation date value of 0.\n\n\n\n\nCode\n## Check reclamation status vs reclamation date\ndate_recla_status &lt;- abandoned_wells_df |&gt; \n        mutate(reclamation_0 = ifelse(reclamation_date == 0, \n                                      \"Date with 0\", \"Date with year\")) |&gt; \n        group_by(reclamation_status, reclamation_0) |&gt;\n        tally()\n\n\nFurther exploration indicates that observations with a zero in reclamation date are categorized as not_reclaimed or reclamation_exempt. Nonetheless, there are 131 observations with year categorized as reclamation_exempt\n\n\nCode\ndate_recla_status |&gt;\n        ggplot(aes(x = reclamation_status, y = n, fill = reclamation_0)) + \n        geom_bar(stat = \"identity\") +\n        theme_light()\n\n\n\n\n\nLet’s check the number of sites per year of the most recent reclamation certification issued:\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(reclamation_date) |&gt; \n        tally() |&gt; \n        filter(reclamation_date != 0) |&gt; \n        ggplot(aes(x = reclamation_date, y = n)) +\n        geom_col() +\n        labs(x = \"Year of the most recent reclamation certification issued\",\n             y = \"Total well sites\") +\n        theme_light()\n\n\n\n\n\n\nNumber of observations with minimun amount of years from reclamation year\nWe need to obtain polygons with a sufficient time range from the last reclamation year to include in the analysis. The following interactive plot helps to explore the number of observations that we have if we select the number of years since the last reclamation certification was issued.\n\n\nCode\n# Create interactive plot that shows number of observations with at least\n# 20 years or X since last year of reclamation\n\nat_least_20 &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_status == \"reclaimed\",\n               reclamation_date != 0) |&gt; \n        mutate(years = max(abandoned_wells_df$reclamation_date) -\n                       reclamation_date) |&gt; \n        filter(years &gt;= 20) |&gt; \n        nrow()\n\n\nThere are 43552 polygons with at least 20 years of data. These polygons were identified after filtering out observations with zero dates and those exclusively categorized as ‘reclaimed’ in the reclamation status.\n\n\nThis is looking just at the reclamation year and reclamation status, without filtering by any other variable. Therefore, number of observations could be lower due to other filtering criteria based on variables other than reclamation maximum year."
  },
  {
    "objectID": "notebooks/abandoned_wells.html#abandoned-date",
    "href": "notebooks/abandoned_wells.html#abandoned-date",
    "title": "Abandoned wells data exploration",
    "section": "Abandoned date",
    "text": "Abandoned date\nAccording to documentation, the variable max_abandoned_date is Indicates the latest (most recent) year a well was abandoned. This is not the same as orphaned. Rather indicates that the wellheads and any sort of infrastructure was removed from the site.\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(max_abandoned_date) |&gt; \n        tally() |&gt; \n        paged_table()\n\n\n\n\n  \n\n\n\nCode\nzero_obs &lt;- abandoned_wells_df |&gt; \n        group_by(max_abandoned_date) |&gt; \n        tally() |&gt; \n        filter(max_abandoned_date == 0) |&gt; \n        select(n) |&gt; \n        pull()\n\n\n\n\n\n\n\n\nImportant\n\n\n\nFrom the summarized table, there are 10039 observations with an abandoned date value of 0.\n\n\n\n\nCode\n## TODO: Organize this exploration of abandoned date\n\n## Abandoned wells means that wells were removed\n## If so, there should be a number of wells when abandoned date is 0\n\n# abandoned_wells_df |&gt; \n#         mutate(zero = ifelse(max_abandoned_date == 0, 0, 1)) |&gt; \n#         group_by(zero) |&gt; \n#         summarise(\n#                 wellheads = sum(number_wellheads)\n#         )\n        \n## Check reclamation status in dates \n# abandoned_wells_df |&gt; \n#         filter(reclamation_date != 0 & max_abandoned_date != 0) |&gt; \n#         mutate(diff = reclamation_date - max_abandoned_date) |&gt; \n#         select(diff, reclamation_date, \n#                max_abandoned_date, reclamation_status) |&gt; \n#         glimpse()\n        \n\nabandoned_wells_df |&gt; \n        mutate(date_zero = ifelse(max_abandoned_date == 0, \"yes\", \"no\")) |&gt; \n        group_by(reclamation_status, date_zero) |&gt; \n        tally() |&gt; \n        ggplot(aes(x = reclamation_status, y = n, fill = date_zero)) + \n        geom_bar(stat = \"identity\") +\n        labs(x = \"Reclamation status\",\n             y = \"Total observations\",\n             title = \"Reclaimed polygons have most of the abandoned date as zero\",\n             subtitle = \"There are just 543 obs with a zero in the abandoned date\") +\n        theme_light()\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nMost of the sites with reclamation_status as reclaimed, do not have an abandoned date zero."
  },
  {
    "objectID": "notebooks/abandoned_wells.html#production-date",
    "href": "notebooks/abandoned_wells.html#production-date",
    "title": "Abandoned wells data exploration",
    "section": "Production date",
    "text": "Production date\nAll sites here are supposedly to be “abandoned” category. The maximum values for all the dates variables are 2022 in the dataset. This is including the production date:\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(max_last_production_date) |&gt; \n        tally() |&gt; \n        filter(max_last_production_date != 0) |&gt; \n        ggplot(aes(x = max_last_production_date, y = n)) +\n        geom_col() +\n        labs(x = \"Year of the most recent production date\",\n             y = \"Total well sites without dates with zero\") +\n        theme_light()\n\n\n\n\n\n\n\nCode\nabandoned_wells_df |&gt; \n        mutate(date_zero = ifelse(max_last_production_date == 0,\n                                  \"yes\", \"no\")) |&gt; \n        group_by(reclamation_status, date_zero) |&gt; \n        tally() |&gt; \n        ggplot(aes(x = reclamation_status, y = n, fill = date_zero)) + \n        geom_bar(stat = \"identity\") +\n        labs(x = \"Reclamation status\",\n             y = \"Total observations\",\n             fill = \"Last production date as zero\",\n             title = \"Reclamation status for last production date variable\",\n             subtitle = \"All reclamation status categories contains values with dates as zero\") +\n        theme_light()"
  },
  {
    "objectID": "notebooks/abandoned_wells.html#reclamation-date-vs-abandoned-date",
    "href": "notebooks/abandoned_wells.html#reclamation-date-vs-abandoned-date",
    "title": "Abandoned wells data exploration",
    "section": "Reclamation date vs Abandoned date",
    "text": "Reclamation date vs Abandoned date\n\n\nCode\ncat &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_date != 0 & max_abandoned_date != 0) |&gt; \n        mutate(diff = reclamation_date - max_abandoned_date) |&gt; \n        select(diff, reclamation_date, max_abandoned_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        mutate(cat = case_when(\n                diff &lt; 0 ~ \"less\",\n                diff &gt; 0 ~ \"more\",\n                diff == 0 ~ \"same\",\n                .default = NA\n        )) |&gt; \n        group_by(cat) |&gt; \n        summarize(\n                total = sum(n)\n        )\n\n\nDoes the reclamation date has to match with abandoned date? In the data set, excluding observations with dates equal to 0, there are 2066 polygons where the abandoned date is more recent than reclamation date, 84460 where the reclamation date is more recent than the abandoned date, and 5118 with both dates being the same.\nThe interactive Figure 4 shows the difference in years distribution of these dates. The differences indicate:\n\n0 = Same year abandoned date reclamation.\n&gt; 0 = Date reclamation is more recent than the abandoned date.\n&lt; 0 = Abandoned date is more recent than reclamation date.\n\n\n\nCode\na &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_date != 0 & max_abandoned_date != 0) |&gt; \n        mutate(diff = reclamation_date - max_abandoned_date) |&gt; \n        select(diff, reclamation_date, max_abandoned_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        # paged_table()\n        ggplot(aes(x = diff, y = n)) +\n        geom_col() +\n        theme_light()\n\nggplotly(a)\n\n\n\n\n\nFigure 4: Distribution of difference in years between reclamation and abandoned dates"
  },
  {
    "objectID": "notebooks/abandoned_wells.html#reclamation-date-vs-last-production-date",
    "href": "notebooks/abandoned_wells.html#reclamation-date-vs-last-production-date",
    "title": "Abandoned wells data exploration",
    "section": "Reclamation date vs Last Production date",
    "text": "Reclamation date vs Last Production date\n\n\nCode\ncat &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_date != 0 & max_last_production_date != 0) |&gt; \n        mutate(diff = reclamation_date - max_last_production_date) |&gt; \n        select(diff, reclamation_date, max_last_production_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        mutate(cat = case_when(\n                diff &lt; 0 ~ \"less\",\n                diff &gt; 0 ~ \"more\",\n                diff == 0 ~ \"same\",\n                .default = NA\n        )) |&gt; \n        group_by(cat) |&gt; \n        summarize(\n                total = sum(n)\n        )\n\n\nHere I have the same question: Does the reclamation date has to match with the last production date? Given that we need polygons with no buildings or infrastructure on it to avoid anomalies in the spectral signature, does the period of production implies that there is some sort of infrastructure in the well area?\nIn this case, excluding observations with dates equal to 0, there are 1111 polygons where the production date is more recent than reclamation date, 18769 where the reclamation date is more recent than the production date, and 133 with both dates being the same.\n\n\nCode\na &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_date != 0 & max_last_production_date != 0) |&gt; \n        mutate(diff = reclamation_date - max_last_production_date) |&gt; \n        select(diff, reclamation_date, max_last_production_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        # paged_table()\n        ggplot(aes(x = diff, y = n)) +\n        geom_col() +\n        theme_light()\n\nggplotly(a)\n\n\n\n\n\nFigure 5: Distribution of difference in years between reclamation and last production dates"
  },
  {
    "objectID": "notebooks/abandoned_wells.html#abandoned-date-vs-last-production-date",
    "href": "notebooks/abandoned_wells.html#abandoned-date-vs-last-production-date",
    "title": "Abandoned wells data exploration",
    "section": "Abandoned date vs Last Production date",
    "text": "Abandoned date vs Last Production date\n\n\nCode\ncat &lt;- abandoned_wells_df |&gt; \n        # filter(reclamation_date == 0) |&gt;\n        filter(max_abandoned_date != 0 & max_last_production_date != 0) |&gt;\n        mutate(diff = max_abandoned_date - max_last_production_date) |&gt; \n        select(diff, max_abandoned_date, max_last_production_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        mutate(cat = case_when(\n                diff &lt; 0 ~ \"less\",\n                diff &gt; 0 ~ \"more\",\n                diff == 0 ~ \"same\",\n                .default = NA\n        )) |&gt; \n        group_by(cat) |&gt; \n        summarize(\n                total = sum(n)\n        )\n\n\nAbandoned date is sometimes zero, does this means it is still in production?\nThere is one variable feature_ty which definition is: “The type or category of human footprint feature”. In this dataset every observation has the category: “WELL-ABAND”, so all the polygons should be abandoned.\nWhen we have 0 in the abandoned date, we have:\n\n4687 observation with max last production date in 0.\nThe maximum date value in the range is 2022 (This is the maximum date value found for every date variable)\n\nAnd then, the distribution of the last production date observations that are not 0:\n\n\nCode\na &lt;- abandoned_wells_df |&gt; \n        filter(max_abandoned_date == 0) |&gt; \n        group_by(max_last_production_date) |&gt; \n        tally() |&gt; \n        filter(max_last_production_date != 0) |&gt; \n        ggplot(aes(x = max_last_production_date, y = n)) +\n        geom_bar(stat = \"identity\") +\n        theme_light()\n\nggplotly(a)\n\n\n\n\n\n\nIn this case, excluding observations with dates equal to 0, there are 779 polygons where the production date is more recent than abandoned date, 55022 where the abandoned date is more recent than the production date, and 7435 with both dates being the same.\n\n\n\n\n\n\nImportant\n\n\n\nDo we need to consider last production dates and abandoned dates to be earlier than the last reclamation date?"
  },
  {
    "objectID": "gee_filtering.html",
    "href": "gee_filtering.html",
    "title": "GEE polygons filters",
    "section": "",
    "text": "Code\nimport ee\nimport geemap\nimport folium\nimport json\nAfter selecting the polygons from the abandoned wells, the following steps will continue with the filtering in GEE."
  },
  {
    "objectID": "gee_filtering.html#create-buffers-in-reservoirs-polygons",
    "href": "gee_filtering.html#create-buffers-in-reservoirs-polygons",
    "title": "GEE polygons filters",
    "section": "Create buffers in Reservoirs polygons",
    "text": "Create buffers in Reservoirs polygons\n\n\nCode\nasset_id = \"projects/ee-ronnyale/assets/reservoirs\"\nreservoirs = ee.FeatureCollection(asset_id)\n\n# Create function to buffer each feature by 30m\ndef buffer_feature(feature):\n  return feature.buffer(30)\n\n# Apply the buffer function to each of the reservoir polygons\nbuffered_reservoirs = reservoirs.map(buffer_feature)\n\n# Plot the buffers in the map\nreservoirs_map = geemap.Map(center=[53.516, -113.498], zoom=5)\nreservoirs_map.addLayer(reservoirs, {\"color\": \"blue\"}, \"reservoirs\")\nreservoirs_map.addLayer(buffered_reservoirs, {'color': '#75AADB'}, \"buffered_reservoirs\")\nreservoirs_map\n\n\n\n            \n            \n\n\n\n\n\n\nFind abandoned wells intersections with reservoirs\nManually, it seems that there is no abandoned well that intersects the reservoirs buffer areas. Nonetheles, we can check this with a function that records if there is an intersection or not. The following show the adding of the new two properties to the feature collection: intersection with the buffer and intersection with the reservoir polygon.\n\n\nCode\n# Function to find intersections between buffered polygons and waterbodies\ndef define_intersection(well):\n    intersects_reservoirs = reservoirs.filterBounds(well.geometry()).size().gt(0)\n    intersects_reservoirs_buffer = buffered_reservoirs.filterBounds(well.geometry()).size().gt(0)\n    return well.set('intersects_reservoirs', intersects_reservoirs) \\\n               .set('intersects_reservoirs_buffer', intersects_reservoirs_buffer)\n\n# Apply the intersection check to each well\nwells_with_intersections = abandoned_wells.map(define_intersection)\n\n# Show a sample\nsample = wells_with_intersections.limit(2).getInfo()\nprint(json.dumps(sample, indent = 2))\n\n\n\n            \n            \n\n\n{\n  \"type\": \"FeatureCollection\",\n  \"columns\": {\n    \"area_ha\": \"Float\",\n    \"disp_nm\": \"String\",\n    \"fetr_ty\": \"String\",\n    \"fieldnm\": \"String\",\n    \"frst_spd_d\": \"Long\",\n    \"frst_spd_y\": \"Integer\",\n    \"hfi_id\": \"String\",\n    \"intersects_reservoirs\": \"Number\",\n    \"intersects_reservoirs_buffer\": \"Number\",\n    \"lcu_id\": \"String\",\n    \"mn_npr_\": \"Integer\",\n    \"mx_bnd_\": \"Integer\",\n    \"mx_ls__\": \"Integer\",\n    \"nmbr_wl\": \"Integer\",\n    \"olsnd__\": \"Integer\",\n    \"plygn_s\": \"Integer\",\n    \"prd_x__\": \"Integer\",\n    \"rclmtn_c\": \"Integer\",\n    \"rclmtn_d\": \"Integer\",\n    \"rclmtn_s\": \"String\",\n    \"shape_r\": \"Float\",\n    \"shp_lng\": \"Float\",\n    \"source\": \"String\",\n    \"system:index\": \"String\",\n    \"visible\": \"Integer\",\n    \"wll_stt\": \"Integer\",\n    \"wllst__\": \"Integer\",\n    \"year\": \"Integer\"\n  },\n  \"version\": 1716336823537424,\n  \"id\": \"projects/ee-ronnyale/assets/selected_polygons\",\n  \"properties\": {\n    \"system:asset_size\": 20098598\n  },\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -115.17626384209883,\n              54.16848147380045\n            ],\n            [\n              -115.17453722252176,\n              54.16848399125569\n            ],\n            [\n              -115.17454141208857,\n              54.169497074721704\n            ],\n            [\n              -115.17626815168443,\n              54.16949462890382\n            ],\n            [\n              -115.17626384209883,\n              54.16848147380045\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000008c46\",\n      \"properties\": {\n        \"area_ha\": 1.272871342643425,\n        \"disp_nm\": \"\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 115200000,\n        \"frst_spd_y\": 1970,\n        \"hfi_id\": \"{72CFB218-1933-42A3-A396-FA16CF35DD7C}\",\n        \"intersects_reservoirs\": 0,\n        \"intersects_reservoirs_buffer\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1970,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"plygn_s\": 9,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 1974,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 12728.713426434248,\n        \"shp_lng\": 451.2863999977708,\n        \"source\": \"AHFMP\",\n        \"visible\": 0,\n        \"wll_stt\": 1,\n        \"wllst__\": 170504,\n        \"year\": 1970\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -111.6258150977823,\n              50.378640889095735\n            ],\n            [\n              -111.62438590584102,\n              50.37859936606693\n            ],\n            [\n              -111.62432064939453,\n              50.37951772649793\n            ],\n            [\n              -111.62574987513887,\n              50.37955925031751\n            ],\n            [\n              -111.6258150977823,\n              50.378640889095735\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000000fd0\",\n      \"properties\": {\n        \"area_ha\": 1.038418064780067,\n        \"disp_nm\": \"\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 201600000,\n        \"frst_spd_y\": 1970,\n        \"hfi_id\": \"{8F8D1B87-32C6-4D03-82E9-08F03963A67C}\",\n        \"intersects_reservoirs\": 0,\n        \"intersects_reservoirs_buffer\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1970,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"plygn_s\": 9,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 1992,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 10384.180647800671,\n        \"shp_lng\": 407.6111999992281,\n        \"source\": \"AHFMP\",\n        \"visible\": 2,\n        \"wll_stt\": 1,\n        \"wllst__\": 29104,\n        \"year\": 1970\n      }\n    }\n  ]\n}"
  },
  {
    "objectID": "gee_filtering.html#waterbodies",
    "href": "gee_filtering.html#waterbodies",
    "title": "GEE polygons filters",
    "section": "Waterbodies",
    "text": "Waterbodies\n\nCreate the waterbodies mask\nFrom all the features we have, I need juts the waterbodies. This is a raster which I also need to reduce to a vector to create the buffer area.\n\n\nCode\n# Water category is 1 (as seen in qgis)\nwater_mask = asset_image.eq(1)\nwater_image = asset_image.updateMask(water_mask)\n\n# Steps from raster to vector\nwater_bodies_vector = water_image.reduceToVectors(\n    geometryType=\"polygon\",\n    scale=10,  # LCC layer documentation states is 10m\n    maxPixels=1e8,\n    bestEffort=True,\n    labelProperty=\"water_bodies\",\n)\n\nwaterbodies_map = geemap.Map(center=[53.516, -113.498], zoom=5)\nwaterbodies_map.addLayer(water_bodies_vector, {\"color\": \"blue\"}, \"waterbodies_mask\")\nwaterbodies_map\n\n\n\n            \n            \n\n\n\n\n\nHow many waterbodies polygons do I have?\n\n\nCode\nprint(water_bodies_vector.size().getInfo())  # Number of water body polygons\n# print(water_bodies_vector.getInfo()) # Query exceeds the API limit\n\n# In case I need the resulting polygons\n# export_task = ee.batch.Export.table.toDrive(\n#     collection = water_bodies_vector,\n#     description = 'water_bodies_polygons',\n#     folder = 'earth_engine_exports',\n#     fileFormat = 'SHP'\n# )\n# export_task.start()\n# print(\"Export started. Check your Google Drive for the results.\")\n\n\n\n            \n            \n\n\n69018\n\n\n\n\nCreate buffers for waterbodies\nBased on the waterbodies resulting polygons, we are going to create a buffer area and then check if any of the abandoned well sites intersects them.\n\n\nCode\n# Function defined above in reservoirs section\nbuffered_waterbodies = water_bodies_vector.map(buffer_feature)\nwaterbodies_buffer_map = geemap.Map(center=[53.516, -113.498], zoom=5)\nwaterbodies_buffer_map.addLayer(\n    water_bodies_vector, {\"color\": \"blue\"}, \"waterbodies_mask\"\n)\nwaterbodies_buffer_map.addLayer(\n    buffered_waterbodies, {\"color\": \"#75AADB\"}, \"waterbodies_buffer\"\n)\nwaterbodies_buffer_map\n\n\n\n            \n            \n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nCheck that when creating the mask from the raster data, not all waterbodies match completely the waterbodies. This can be seen when zooming in the visualization.\n\n\n\n\nFind abandoned wells intersections with waterbodies\n\n\nCode\n# Function to check if a well intersects with waterbodies or buffered waterbodies\ndef define_intersection(well):\n    intersects_waterbody = water_bodies_vector.filterBounds(well.geometry()).size().gt(0)\n    intersects_buffer = buffered_waterbodies.filterBounds(well.geometry()).size().gt(0)\n    return well.set('intersects_waterbody', intersects_waterbody.toInt()) \\\n               .set('intersects_buffer', intersects_buffer.toInt())\n\n# Apply the intersection check to each well\nwells_with_intersections = abandoned_wells.map(define_intersection)\n\n# Show a sample\nsample = wells_with_intersections.limit(2).getInfo()\nprint(json.dumps(sample, indent = 2))\n\n\n\n            \n            \n\n\n{\n  \"type\": \"FeatureCollection\",\n  \"columns\": {\n    \"area_ha\": \"Float\",\n    \"disp_nm\": \"String\",\n    \"fetr_ty\": \"String\",\n    \"fieldnm\": \"String\",\n    \"frst_spd_d\": \"Long\",\n    \"frst_spd_y\": \"Integer\",\n    \"hfi_id\": \"String\",\n    \"intersects_buffer\": \"Number\",\n    \"intersects_waterbody\": \"Number\",\n    \"lcu_id\": \"String\",\n    \"mn_npr_\": \"Integer\",\n    \"mx_bnd_\": \"Integer\",\n    \"mx_ls__\": \"Integer\",\n    \"nmbr_wl\": \"Integer\",\n    \"olsnd__\": \"Integer\",\n    \"plygn_s\": \"Integer\",\n    \"prd_x__\": \"Integer\",\n    \"rclmtn_c\": \"Integer\",\n    \"rclmtn_d\": \"Integer\",\n    \"rclmtn_s\": \"String\",\n    \"shape_r\": \"Float\",\n    \"shp_lng\": \"Float\",\n    \"source\": \"String\",\n    \"system:index\": \"String\",\n    \"visible\": \"Integer\",\n    \"wll_stt\": \"Integer\",\n    \"wllst__\": \"Integer\",\n    \"year\": \"Integer\"\n  },\n  \"version\": 1716336823537424,\n  \"id\": \"projects/ee-ronnyale/assets/selected_polygons\",\n  \"properties\": {\n    \"system:asset_size\": 20098598\n  },\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -115.17626384209883,\n              54.16848147380045\n            ],\n            [\n              -115.17453722252176,\n              54.16848399125569\n            ],\n            [\n              -115.17454141208857,\n              54.169497074721704\n            ],\n            [\n              -115.17626815168443,\n              54.16949462890382\n            ],\n            [\n              -115.17626384209883,\n              54.16848147380045\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000008c46\",\n      \"properties\": {\n        \"area_ha\": 1.272871342643425,\n        \"disp_nm\": \"\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 115200000,\n        \"frst_spd_y\": 1970,\n        \"hfi_id\": \"{72CFB218-1933-42A3-A396-FA16CF35DD7C}\",\n        \"intersects_buffer\": 1,\n        \"intersects_waterbody\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1970,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"plygn_s\": 9,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 1974,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 12728.713426434248,\n        \"shp_lng\": 451.2863999977708,\n        \"source\": \"AHFMP\",\n        \"visible\": 0,\n        \"wll_stt\": 1,\n        \"wllst__\": 170504,\n        \"year\": 1970\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -111.6258150977823,\n              50.378640889095735\n            ],\n            [\n              -111.62438590584102,\n              50.37859936606693\n            ],\n            [\n              -111.62432064939453,\n              50.37951772649793\n            ],\n            [\n              -111.62574987513887,\n              50.37955925031751\n            ],\n            [\n              -111.6258150977823,\n              50.378640889095735\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000000fd0\",\n      \"properties\": {\n        \"area_ha\": 1.038418064780067,\n        \"disp_nm\": \"\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 201600000,\n        \"frst_spd_y\": 1970,\n        \"hfi_id\": \"{8F8D1B87-32C6-4D03-82E9-08F03963A67C}\",\n        \"intersects_buffer\": 0,\n        \"intersects_waterbody\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1970,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"plygn_s\": 9,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 1992,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 10384.180647800671,\n        \"shp_lng\": 407.6111999992281,\n        \"source\": \"AHFMP\",\n        \"visible\": 2,\n        \"wll_stt\": 1,\n        \"wllst__\": 29104,\n        \"year\": 1970\n      }\n    }\n  ]\n}"
  },
  {
    "objectID": "gee_filtering.html#developed-area",
    "href": "gee_filtering.html#developed-area",
    "title": "GEE polygons filters",
    "section": "Developed area",
    "text": "Developed area\n\nI will follow same process as waterbodies to create a mask (convert to vector) and then create the buffers\n\n\n\nCode\ndeveloped_mask = asset_image.eq(13)\ndeveloped_image = asset_image.updateMask(developed_mask)\n\ndeveloped_vector = developed_image.reduceToVectors(\n    geometryType=\"polygon\",\n    scale=10,\n    maxPixels=1e8,\n    bestEffort=True,\n    labelProperty=\"developed_areas\",\n)\n\nbuffered_developed_areas = developed_vector.map(buffer_feature)\n\ndeveloped_map = geemap.Map(center=[53.516, -113.498], zoom=5)\ndeveloped_map.addLayer(developed_vector, {\"color\": \"gray\"})\ndeveloped_map.addLayer(buffered_developed_areas, {\"color\": \"red\"})\ndeveloped_map\n\n# # Find intersections with developed areas\n# def define_intersection(well):\n#     intersects_developed_areas = developed_vector.filterBounds(well.geometry()).size().gt(0)\n#     intersects_buffer = buffered_developed_areas.filterBounds(well.geometry()).size().gt(0)\n#     return well.set('intersects_developed_areas', intersects_developed_areas.toInt()) \\\n#                .set('intersects_buffer_developed_areas', intersects_buffer.toInt())\n\n# # Apply the intersection check to each well\n# wells_with_intersections_developed_areas = abandoned_wells.map(define_intersection)\n\n# # Show a sample\n# sample = wells_with_intersections_developed_areas.limit(2).getInfo()\n# print(json.dumps(sample, indent = 2))\n\n\n\n            \n            \n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nI didn’t use the developed_area category from the AER data that is a raster. Rather I used the ABMI data which is already a vector and contains the residential and industrial categories to create the buffers and check which abandoned wells intersect those."
  },
  {
    "objectID": "gee_filtering.html#glimpse-of-the-flagged-feature-collection",
    "href": "gee_filtering.html#glimpse-of-the-flagged-feature-collection",
    "title": "GEE polygons filters",
    "section": "Glimpse of the flagged feature collection",
    "text": "Glimpse of the flagged feature collection\nHere is a glimpse of the new properties created with the flagged intersections. Also, the number of abandoned wells polygons to be filter out.\n\n\nCode\nintersects_asset_id = \"projects/ee-ronnyale/assets/intersecting_wells_flags_v2\"\nintersects = ee.FeatureCollection(intersects_asset_id)\n\n# Get all polygons with an intersetion\nfilters = [\n    ee.Filter.eq(\"intersects_industrial\", 1),\n    ee.Filter.eq(\"intersects_industrial_buffer\", 1),\n    ee.Filter.eq(\"intersects_reservoirs\", 1),\n    ee.Filter.eq(\"intersects_reservoirs_buffer\", 1),\n    ee.Filter.eq(\"intersects_residential\", 1),\n    ee.Filter.eq(\"intersects_residential_buffer\", 1),\n    ee.Filter.eq(\"intersects_roads\", 1),\n    ee.Filter.eq(\"intersects_roads_buffer\", 1),\n    ee.Filter.eq(\"intersects_waterbodies\", 1),\n    ee.Filter.eq(\"intersects_waterbody_buffer\", 1),\n]\n\n# Combine the filters using ee.Filter.or\ncombined_filter = ee.Filter.Or(*filters)\n\n# Apply the combined filter to the feature collection\nintersecting_features = intersects.filter(combined_filter)\n\nsample = intersecting_features.limit(2).getInfo()\nprint(json.dumps(sample, indent=2))\nprint(intersecting_features.size().getInfo())\n\n\n\n            \n            \n\n\n{\n  \"type\": \"FeatureCollection\",\n  \"columns\": {\n    \"area_ha\": \"Float\",\n    \"disp_nm\": \"String\",\n    \"fetr_ty\": \"String\",\n    \"fieldnm\": \"String\",\n    \"frst_spd_d\": \"Long\",\n    \"frst_spd_y\": \"Integer\",\n    \"hfi_id\": \"String\",\n    \"intersects_industrial\": \"Long\",\n    \"intersects_industrial_buffer\": \"Long\",\n    \"intersects_reservoirs\": \"Long\",\n    \"intersects_reservoirs_buffer\": \"Long\",\n    \"intersects_residential\": \"Long\",\n    \"intersects_residential_buffer\": \"Long\",\n    \"intersects_roads\": \"Long\",\n    \"intersects_roads_buffer\": \"Long\",\n    \"intersects_waterbodies\": \"Long\",\n    \"intersects_waterbody_buffer\": \"Long\",\n    \"lcu_id\": \"String\",\n    \"mn_npr_\": \"Integer\",\n    \"mx_bnd_\": \"Integer\",\n    \"mx_ls__\": \"Integer\",\n    \"nmbr_wl\": \"Integer\",\n    \"olsnd__\": \"Integer\",\n    \"plygn_s\": \"Integer\",\n    \"prd_x__\": \"Integer\",\n    \"rclmtn_c\": \"Integer\",\n    \"rclmtn_d\": \"Integer\",\n    \"rclmtn_s\": \"String\",\n    \"shape_r\": \"Float\",\n    \"shp_lng\": \"Float\",\n    \"source\": \"String\",\n    \"system:index\": \"String\",\n    \"visible\": \"Integer\",\n    \"wll_stt\": \"Integer\",\n    \"wllst__\": \"Integer\",\n    \"year\": \"Integer\"\n  },\n  \"version\": 1716983263842881,\n  \"id\": \"projects/ee-ronnyale/assets/intersecting_wells_flags_v2\",\n  \"properties\": {\n    \"system:asset_size\": 20072004\n  },\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -112.68162815068959,\n              51.05977825484342\n            ],\n            [\n              -112.68164020300942,\n              51.05897008678425\n            ],\n            [\n              -112.68054210325442,\n              51.058961704207235\n            ],\n            [\n              -112.68035777186363,\n              51.05896251896173\n            ],\n            [\n              -112.68034569219773,\n              51.05977068742345\n            ],\n            [\n              -112.68162815068959,\n              51.05977825484342\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000000024\",\n      \"properties\": {\n        \"area_ha\": 0.810006630122344,\n        \"disp_nm\": \"MSL010842\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 985334400000,\n        \"frst_spd_y\": 2001,\n        \"hfi_id\": \"{1CA6D4B1-B26C-449E-BDF8-923813075B13}\",\n        \"intersects_industrial\": 0,\n        \"intersects_industrial_buffer\": 0,\n        \"intersects_reservoirs\": 0,\n        \"intersects_reservoirs_buffer\": 0,\n        \"intersects_residential\": 0,\n        \"intersects_residential_buffer\": 0,\n        \"intersects_roads\": 0,\n        \"intersects_roads_buffer\": 0,\n        \"intersects_waterbodies\": 1,\n        \"intersects_waterbody_buffer\": 1,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 2001,\n        \"mx_bnd_\": 2013,\n        \"mx_ls__\": 2012,\n        \"nmbr_wl\": 1,\n        \"olsnd__\": null,\n        \"plygn_s\": 1,\n        \"prd_x__\": 2,\n        \"rclmtn_c\": 3,\n        \"rclmtn_d\": 2016,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 8100.066301223439,\n        \"shp_lng\": 360.0012614489656,\n        \"source\": \"AHFMP\",\n        \"visible\": 2,\n        \"wll_stt\": 1,\n        \"wllst__\": 267653,\n        \"year\": 2001\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -115.87584796786865,\n              54.55362614532342\n            ],\n            [\n              -115.875204692006,\n              54.552988137749416\n            ],\n            [\n              -115.87356385212406,\n              54.55273220383654\n            ],\n            [\n              -115.87319658902395,\n              54.553511442392335\n            ],\n            [\n              -115.87484522577167,\n              54.55377179362033\n            ],\n            [\n              -115.87491130596025,\n              54.553628468033594\n            ],\n            [\n              -115.87511654183191,\n              54.5531717727261\n            ],\n            [\n              -115.87557928040698,\n              54.55362806724955\n            ],\n            [\n              -115.87584796786865,\n              54.55362614532342\n            ]\n          ]\n        ]\n      },\n      \"id\": \"0000000000000000010b\",\n      \"properties\": {\n        \"area_ha\": 1.096115021944638,\n        \"disp_nm\": \"MSL991228\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 939970800000,\n        \"frst_spd_y\": 1999,\n        \"hfi_id\": \"{058AFD84-5B2D-4A94-8602-6647A4E61E3E}\",\n        \"intersects_industrial\": 1,\n        \"intersects_industrial_buffer\": 1,\n        \"intersects_reservoirs\": 0,\n        \"intersects_reservoirs_buffer\": 0,\n        \"intersects_residential\": 0,\n        \"intersects_residential_buffer\": 0,\n        \"intersects_roads\": 0,\n        \"intersects_roads_buffer\": 0,\n        \"intersects_waterbodies\": 0,\n        \"intersects_waterbody_buffer\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1999,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"olsnd__\": null,\n        \"plygn_s\": 2,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 2007,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 10961.150219446377,\n        \"shp_lng\": 537.8595521247555,\n        \"source\": \"AHFMP\",\n        \"visible\": 2,\n        \"wll_stt\": 1,\n        \"wllst__\": 298532,\n        \"year\": 1999\n      }\n    }\n  ]\n}\n19639"
  },
  {
    "objectID": "gee_filtering.html#visualization-of-intersecting-abandoned-wells",
    "href": "gee_filtering.html#visualization-of-intersecting-abandoned-wells",
    "title": "GEE polygons filters",
    "section": "Visualization of intersecting abandoned wells",
    "text": "Visualization of intersecting abandoned wells\n\n\nCode\n# ABMI vector layers\nasset_flagged = \"projects/ee-ronnyale/assets/intersecting_wells_flags\"\nabandoned_wells = ee.FeatureCollection(asset_flagged)\n\n## Industrial ABMI\nasset_id = \"projects/ee-ronnyale/assets/industrial\"\nasset_industrial = ee.FeatureCollection(asset_id)\n\n## Residential ABMI\nasset_id = \"projects/ee-ronnyale/assets/residentials\"\nasset_residential = ee.FeatureCollection(asset_id)\n\n## Roads ABMI\nasset_id = \"projects/ee-ronnyale/assets/roads\"\nasset_roads = ee.FeatureCollection(asset_id)\n\n## Create buffer industrial-residential-roads\nbuffered_industrial = asset_industrial.map(buffer_feature)\nbuffered_residential = asset_residential.map(buffer_feature)\nbuffered_roads = asset_roads.map(buffer_feature)\n\n# Plot abandoned wells that intersect waterbodies\nwells_intersecting_map = geemap.Map(center=[53.516, -113.498], zoom=5)\n\n## Reservoirs\nwells_intersecting_map.addLayer(reservoirs, {\"color\": \"blue\"}, \"reservoirs\")\nwells_intersecting_map.addLayer(\n    buffered_reservoirs, {\"color\": \"#75AADB\"}, \"reservoirs_buffer\"\n)\n\n## Waterbodies\nwells_intersecting_map.addLayer(\n    water_bodies_vector, {\"color\": \"blue\"}, \"waterbodies_mask\"\n)\nwells_intersecting_map.addLayer(\n    buffered_waterbodies, {\"color\": \"#75AADB\"}, \"waterbodies_buffer\"\n)\n\n## Industrial\nwells_intersecting_map.addLayer(asset_industrial, {\"color\": \"#2B2D42\"}, \"industrial\")\nwells_intersecting_map.addLayer(\n    buffered_industrial, {\"color\": \"#8D99AE\"}, \"industrial_buffer\"\n)\n\n## Residential\nwells_intersecting_map.addLayer(asset_residential, {\"color\": \"#F77F00\"}, \"residential\")\nwells_intersecting_map.addLayer(\n    buffered_residential, {\"color\": \"#FCBF49\"}, \"residential_buffer\"\n)\n\n## Roads\nwells_intersecting_map.addLayer(asset_roads, {\"color\": \"#212529\"}, \"roads\")\nwells_intersecting_map.addLayer(buffered_roads, {\"color\": \"#343A40\"}, \"rodas_buffer\")\n\nwells_intersecting_map.addLayer(\n    intersecting_features, {\"color\": \"#FBFF12\"}, \"abandoned_wells\"\n)\nwells_intersecting_map"
  },
  {
    "objectID": "abandoned_wells.html",
    "href": "abandoned_wells.html",
    "title": "Abandoned wells data exploration",
    "section": "",
    "text": "This is an Exploratory Data Analysis to understand the data characteristics of the layer o16_WellsAbnd_HFI_2021 from the Wall-to-Wall Human Footprint Inventory by the Alberta Biodiversity Monitoring Institute.\nThe aim is to identify characteristics that may aid in selecting polygons for subsequent analysis.\nFor the findings summary, go to Key findings"
  },
  {
    "objectID": "abandoned_wells.html#unique-values-per-variable",
    "href": "abandoned_wells.html#unique-values-per-variable",
    "title": "Abandoned wells data exploration",
    "section": "Unique values per variable",
    "text": "Unique values per variable\nHow many unique values do we have per variable?\n\n\nCode\nabandoned_wells_df |&gt; \n        map_dfr(~n_distinct(.x)) |&gt; \n        paged_table()\n\n\n\n\n  \n\n\n\nInsights from the output:\n\nfootprint_id does not match the number of observations. Check if there are NA’s in polygons and why.\nwell_status we just have 1 which means abandoned.\nspud_date and spud_year are the date when drilling first began on the well pad. 125 different years in the registry? Check how many years of data we have.\nThe number_wellheads is the total number of wellbores on the well pad. Does this have an impact in the reclamation process?\nvisible variable probably have NA's. There should be just 3 values: 0 = not visible, 1 = fully visible, 2 = partially visible. This reflects the state of visibility of a footprint. No idea what this means.\noilsands_evaluation_well we have just the 2 categories described in documentation: 0 = No Oil Sands Evaluation (OSE) well, 1 = OSE well present.\nCheck distribution of variable reclamation_status.\nreclamation_date it’s the most recent reclamation certification."
  },
  {
    "objectID": "abandoned_wells.html#key-variable",
    "href": "abandoned_wells.html#key-variable",
    "title": "Abandoned wells data exploration",
    "section": "Key variable",
    "text": "Key variable\nWhat is each row? The dataset has 182189 observations that should match the same amount of unique values for one of the variables contained in the dataset. The variable closer to this number is footprint_id, but it has less number of unique values. What are they?\nAssuming that each row in the dataset is one unique site (or one unique observation), the wellsite_footprint_id should have one observation per each id.\nWhen grouping all the observations per wellsite_footprint_id, I found those id’s that have more than 1 observation as shown in Table 1.\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(wellsite_footprint_id) |&gt; \n        tally(sort = T) |&gt; \n        filter(n &gt; 1) |&gt; \n        gt()\n\n\n\n\n\n\nTable 1:  Well site id’s with more than 1 observation \n  \n    \n      wellsite_footprint_id\n      n\n    \n  \n  \n    NA\n1001\n    109118\n3\n    109503\n3\n    268598\n2\n    287438\n2\n    305376\n2\n    313410\n2\n    317515\n2\n    319334\n2\n    320068\n2\n    320225\n2\n    320312\n2\n    321608\n2\n    323037\n2\n    323334\n2\n    323467\n2\n    324441\n2\n    324474\n2\n    324597\n2\n    324936\n2\n    325167\n2\n    325895\n2\n    326530\n2\n    326601\n2\n    326972\n2\n    327070\n2\n    328678\n2\n    345923\n2\n  \n  \n  \n\n\n\n\n\nThe Table 2, shows every well site with more than 1 observation per id. In total, there are 56 well sites with this condition, excluding the observations with NAs. It seems to have the same values for each of its variables except for the shape_length and shape_area.\n\n\nCode\nrepeated_ids &lt;- abandoned_wells_df |&gt; \n        group_by(wellsite_footprint_id) |&gt; \n        tally() |&gt; \n        filter(n &gt; 1 & !is.na(wellsite_footprint_id)) |&gt; \n        select(wellsite_footprint_id) |&gt; \n        pull()\n\nabandoned_wells_df |&gt; \n        filter(wellsite_footprint_id %in% repeated_ids) |&gt; \n        arrange(wellsite_footprint_id) |&gt; \n        paged_table()\n\n\n\n\n Table 2:  Data frame subset of the well sites which have more than 1\nobservation per id \n  \n\n\n\n\nThe Figure 1 plots of the observations with the same id shows that probably, some well sites, are composed by more than 1 polygon. They look relatively close. This segmentation explains the differences in the shape_length and shape_area variables when the rest of the variables are the exact same per id\n\n\nCode\na &lt;- abandoned_wells |&gt; \n        filter(wellsite_footprint_id == 109118) |&gt; \n        ggplot() +\n        geom_sf() \n\nb &lt;- abandoned_wells |&gt; \n        filter(wellsite_footprint_id == 109503) |&gt; \n        ggplot() +\n        geom_sf()\n\nc &lt;- abandoned_wells |&gt; \n        filter(wellsite_footprint_id == 268598) |&gt; \n        ggplot() +\n        geom_sf()\n\nd &lt;- abandoned_wells |&gt; \n        filter(wellsite_footprint_id == 287438) |&gt; \n        ggplot() +\n        geom_sf()\n\nplot_grid(a, b, c, d, labels = c('A', 'B', 'C', 'D'))\n\n\n\n\n\nFigure 1: Polygons with the same well site id\n\n\n\n\n\nWhat is happening with the NA’s in id?\nThere are 1001 observations which have NA in the wellsite_footprint_id variable. The Figure 2 shows that together with the wellsite_footprint_id, the disp_num, lcu_id, and the vast majority of fieldname observations are also NAs.\n\n\nCode\nabandoned_wells_df |&gt; \n        filter(is.na(wellsite_footprint_id) == TRUE) |&gt; \n        vis_dat(sort_type = F)\n\n\n\n\n\nFigure 2: Observations with NA in the well site id variable\n\n\n\n\nPolygons with NA’s in their ids seems to be fine (not segmented or empty). The Figure 3 shows two of them.\n\n\nCode\na &lt;- abandoned_wells |&gt; \n        filter(is.na(wellsite_footprint_id) == TRUE) |&gt; \n        slice(34) |&gt; \n        ggplot() +\n        geom_sf() \n\nb &lt;- abandoned_wells |&gt; \n        filter(is.na(wellsite_footprint_id) == TRUE) |&gt; \n        slice(534) |&gt; \n        ggplot() +\n        geom_sf() \n\nplot_grid(a, b, labels = c('A', 'B'))\n\n\n\n\n\nFigure 3: Polygons with NAs in their ids\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nThere are 27 “segmented polygons” which are represented by the same id. Also we have 1001 NA’s in the well site ids, which have at the same time NAs in disp_num, lcu_id, and fieldname\nShould we exclude the 56 segmented polygons? Do we want to use polygons without any id?"
  },
  {
    "objectID": "abandoned_wells.html#character-variables",
    "href": "abandoned_wells.html#character-variables",
    "title": "Abandoned wells data exploration",
    "section": "Character variables",
    "text": "Character variables\nWe have just 6 character variables. Nonetheless, I should take into account that other variables with categories are encoded with numbers and I should check the ABMI data document to understand the meaning. The table ?@tbl-character_variables\n\n\nCode\nabandoned_wells_df |&gt; \n        select_if(is.character) |&gt; \n        glimpse() \n\n\n\n?(caption)\n\n\n\nRows: 182,189\nColumns: 7\n$ disp_num           &lt;chr&gt; \"MSL974346\", NA, NA, \"MSL920658\", NA, NA, NA, NA, N…\n$ lcu_id             &lt;chr&gt; NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ reclamation_status &lt;chr&gt; \"not_reclaimed\", \"not_reclaimed\", \"reclaimed\", \"not…\n$ fieldname          &lt;chr&gt; NA, \"ATHABASCA Oil Sands\", \"ATHABASCA Oil Sands\", N…\n$ feature_ty         &lt;chr&gt; \"WELL-ABAND\", \"WELL-ABAND\", \"WELL-ABAND\", \"WELL-ABA…\n$ source             &lt;chr&gt; \"AHFMP\", \"AHFMP\", \"AHFMP\", \"AHFMP\", \"AHFMP\", \"AHFMP…\n$ hfi_id             &lt;chr&gt; \"{4F2CC0D4-6909-433C-A609-2F7AD77AEDA0}\", \"{018C1EC…\n\n\n\n\nCheck unique values per character variable:\n\n\nCode\n# Check number of distinct observations\nabandoned_wells_df |&gt; \n        select_if(is.character) |&gt; \n        map(~n_distinct(.x))\n\n\n$disp_num\n[1] 36124\n\n$lcu_id\n[1] 1050\n\n$reclamation_status\n[1] 3\n\n$fieldname\n[1] 4\n\n$feature_ty\n[1] 1\n\n$source\n[1] 4\n\n$hfi_id\n[1] 182142\n\n\nCode\n# Check categories \nabandoned_wells_df |&gt; \n        select_if(is.character) |&gt; \n        select(-hfi_id, -disp_num, -lcu_id) |&gt;\n        map(~unique(.x))\n\n\n$reclamation_status\n[1] \"not_reclaimed\"      \"reclaimed\"          \"reclamation_exempt\"\n\n$fieldname\n[1] NA                      \"ATHABASCA Oil Sands\"   \"COLD LAKE Oil Sands\"  \n[4] \"PEACE RIVER Oil Sands\"\n\n$feature_ty\n[1] \"WELL-ABAND\"\n\n$source\n[1] \"AHFMP\"  \"ABMI21\" \"ABMI19\" \"ABMI\"  \n\n\n\n\nCode\n# abandoned_wells_df |&gt; \n#         vis_dat(warn_large_data = FALSE)\n\n\n\n\n\n\n\n\nNote\n\n\n\nEverything seems fine with the character variables. Not much information seems to be useful for the analysis.\nThere is just the category abandoned, 3 fieldnames and 4 data sources"
  },
  {
    "objectID": "abandoned_wells.html#reclamation-date",
    "href": "abandoned_wells.html#reclamation-date",
    "title": "Abandoned wells data exploration",
    "section": "Reclamation date",
    "text": "Reclamation date\nWe need to obtain the latest reclamation date for each of the polygons. One site could potentially have several reclamation dates, but we have no way to find out that information from this dataset. Also we are considering using just the last reclamation date for the analysis. This dataset has reclamation dates that span 0, 2022.\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(reclamation_date) |&gt; \n        tally() |&gt; \n        paged_table()\n\n\n\n\n  \n\n\n\nCode\nzero_obs &lt;- abandoned_wells_df |&gt; \n        group_by(reclamation_date) |&gt; \n        tally() |&gt; \n        filter(reclamation_date == 0) |&gt; \n        select(n) |&gt; \n        pull()\n\n\n\n\n\n\n\n\nImportant\n\n\n\nFrom the summarized table, there are 89915 observations with a year reclamation date value of 0.\n\n\n\n\nCode\n## Check reclamation status vs reclamation date\ndate_recla_status &lt;- abandoned_wells_df |&gt; \n        mutate(reclamation_0 = ifelse(reclamation_date == 0, \n                                      \"Date with 0\", \"Date with year\")) |&gt; \n        group_by(reclamation_status, reclamation_0) |&gt;\n        tally()\n\n\nFurther exploration indicates that observations with a zero in reclamation date are categorized as not_reclaimed or reclamation_exempt. Nonetheless, there are 131 observations with year categorized as reclamation_exempt\n\n\nCode\ndate_recla_status |&gt;\n        ggplot(aes(x = reclamation_status, y = n, fill = reclamation_0)) + \n        geom_bar(stat = \"identity\") +\n        theme_light()\n\n\n\n\n\nLet’s check the number of sites per year of the most recent reclamation certification issued:\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(reclamation_date) |&gt; \n        tally() |&gt; \n        filter(reclamation_date != 0) |&gt; \n        ggplot(aes(x = reclamation_date, y = n)) +\n        geom_col() +\n        labs(x = \"Year of the most recent reclamation certification issued\",\n             y = \"Total well sites\") +\n        theme_light()\n\n\n\n\n\n\nNumber of observations with minimun amount of years from reclamation year\nWe need to obtain polygons with a sufficient time range from the last reclamation year to include in the analysis. The following interactive plot helps to explore the number of observations that we have if we select the number of years since the last reclamation certification was issued.\n\n\nCode\n# Create interactive plot that shows number of observations with at least\n# 20 years or X since last year of reclamation\n\nat_least_20 &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_status == \"reclaimed\",\n               reclamation_date != 0) |&gt; \n        mutate(years = max(abandoned_wells_df$reclamation_date) -\n                       reclamation_date) |&gt; \n        filter(years &gt;= 20) |&gt; \n        nrow()\n\n\nThere are 43552 polygons with at least 20 years of data. These polygons were identified after filtering out observations with zero dates and those exclusively categorized as ‘reclaimed’ in the reclamation status.\n\n\nThis is looking just at the reclamation year and reclamation status, without filtering by any other variable. Therefore, number of observations could be lower due to other filtering criteria based on variables other than reclamation maximum year."
  },
  {
    "objectID": "abandoned_wells.html#abandoned-date",
    "href": "abandoned_wells.html#abandoned-date",
    "title": "Abandoned wells data exploration",
    "section": "Abandoned date",
    "text": "Abandoned date\nAccording to documentation, the variable max_abandoned_date is Indicates the latest (most recent) year a well was abandoned. This is not the same as orphaned. Rather indicates that the wellheads and any sort of infrastructure was removed from the site.\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(max_abandoned_date) |&gt; \n        tally() |&gt; \n        paged_table()\n\n\n\n\n  \n\n\n\nCode\nzero_obs &lt;- abandoned_wells_df |&gt; \n        group_by(max_abandoned_date) |&gt; \n        tally() |&gt; \n        filter(max_abandoned_date == 0) |&gt; \n        select(n) |&gt; \n        pull()\n\n\n\n\n\n\n\n\nImportant\n\n\n\nFrom the summarized table, there are 10039 observations with an abandoned date value of 0.\n\n\n\n\nCode\n## TODO: Organize this exploration of abandoned date\n\n## Abandoned wells means that wells were removed\n## If so, there should be a number of wells when abandoned date is 0\n\n# abandoned_wells_df |&gt; \n#         mutate(zero = ifelse(max_abandoned_date == 0, 0, 1)) |&gt; \n#         group_by(zero) |&gt; \n#         summarise(\n#                 wellheads = sum(number_wellheads)\n#         )\n        \n## Check reclamation status in dates \n# abandoned_wells_df |&gt; \n#         filter(reclamation_date != 0 & max_abandoned_date != 0) |&gt; \n#         mutate(diff = reclamation_date - max_abandoned_date) |&gt; \n#         select(diff, reclamation_date, \n#                max_abandoned_date, reclamation_status) |&gt; \n#         glimpse()\n        \n\nabandoned_wells_df |&gt; \n        mutate(date_zero = ifelse(max_abandoned_date == 0, \"yes\", \"no\")) |&gt; \n        group_by(reclamation_status, date_zero) |&gt; \n        tally() |&gt; \n        ggplot(aes(x = reclamation_status, y = n, fill = date_zero)) + \n        geom_bar(stat = \"identity\") +\n        labs(x = \"Reclamation status\",\n             y = \"Total observations\",\n             title = \"Reclaimed polygons have most of the abandoned date as zero\",\n             subtitle = \"There are just 543 obs with a zero in the abandoned date\") +\n        theme_light()\n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\n\nMost of the sites with reclamation_status as reclaimed, do not have an abandoned date zero."
  },
  {
    "objectID": "abandoned_wells.html#production-date",
    "href": "abandoned_wells.html#production-date",
    "title": "Abandoned wells data exploration",
    "section": "Production date",
    "text": "Production date\nAll sites here are supposedly to be “abandoned” category. The maximum values for all the dates variables are 2022 in the dataset. This is including the production date:\n\n\nCode\nabandoned_wells_df |&gt; \n        group_by(max_last_production_date) |&gt; \n        tally() |&gt; \n        filter(max_last_production_date != 0) |&gt; \n        ggplot(aes(x = max_last_production_date, y = n)) +\n        geom_col() +\n        labs(x = \"Year of the most recent production date\",\n             y = \"Total well sites without dates with zero\") +\n        theme_light()\n\n\n\n\n\n\n\nCode\nabandoned_wells_df |&gt; \n        mutate(date_zero = ifelse(max_last_production_date == 0,\n                                  \"yes\", \"no\")) |&gt; \n        group_by(reclamation_status, date_zero) |&gt; \n        tally() |&gt; \n        ggplot(aes(x = reclamation_status, y = n, fill = date_zero)) + \n        geom_bar(stat = \"identity\") +\n        labs(x = \"Reclamation status\",\n             y = \"Total observations\",\n             fill = \"Last production date as zero\",\n             title = \"Reclamation status for last production date variable\",\n             subtitle = \"All reclamation status categories contains values with dates as zero\") +\n        theme_light()"
  },
  {
    "objectID": "abandoned_wells.html#reclamation-date-vs-abandoned-date",
    "href": "abandoned_wells.html#reclamation-date-vs-abandoned-date",
    "title": "Abandoned wells data exploration",
    "section": "Reclamation date vs Abandoned date",
    "text": "Reclamation date vs Abandoned date\n\n\nCode\ncat &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_date != 0 & max_abandoned_date != 0) |&gt; \n        mutate(diff = reclamation_date - max_abandoned_date) |&gt; \n        select(diff, reclamation_date, max_abandoned_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        mutate(cat = case_when(\n                diff &lt; 0 ~ \"less\",\n                diff &gt; 0 ~ \"more\",\n                diff == 0 ~ \"same\",\n                .default = NA\n        )) |&gt; \n        group_by(cat) |&gt; \n        summarize(\n                total = sum(n)\n        )\n\n\nDoes the reclamation date has to match with abandoned date? In the data set, excluding observations with dates equal to 0, there are 2066 polygons where the abandoned date is more recent than reclamation date, 84460 where the reclamation date is more recent than the abandoned date, and 5118 with both dates being the same.\nThe interactive Figure 4 shows the difference in years distribution of these dates. The differences indicate:\n\n0 = Same year abandoned date reclamation.\n&gt; 0 = Date reclamation is more recent than the abandoned date.\n&lt; 0 = Abandoned date is more recent than reclamation date.\n\n\n\nCode\na &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_date != 0 & max_abandoned_date != 0) |&gt; \n        mutate(diff = reclamation_date - max_abandoned_date) |&gt; \n        select(diff, reclamation_date, max_abandoned_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        # paged_table()\n        ggplot(aes(x = diff, y = n)) +\n        geom_col() +\n        theme_light()\n\nggplotly(a)\n\n\n\n\n\nFigure 4: Distribution of difference in years between reclamation and abandoned dates"
  },
  {
    "objectID": "abandoned_wells.html#reclamation-date-vs-last-production-date",
    "href": "abandoned_wells.html#reclamation-date-vs-last-production-date",
    "title": "Abandoned wells data exploration",
    "section": "Reclamation date vs Last Production date",
    "text": "Reclamation date vs Last Production date\n\n\nCode\ncat &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_date != 0 & max_last_production_date != 0) |&gt; \n        mutate(diff = reclamation_date - max_last_production_date) |&gt; \n        select(diff, reclamation_date, max_last_production_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        mutate(cat = case_when(\n                diff &lt; 0 ~ \"less\",\n                diff &gt; 0 ~ \"more\",\n                diff == 0 ~ \"same\",\n                .default = NA\n        )) |&gt; \n        group_by(cat) |&gt; \n        summarize(\n                total = sum(n)\n        )\n\n\nHere I have the same question: Does the reclamation date has to match with the last production date? Given that we need polygons with no buildings or infrastructure on it to avoid anomalies in the spectral signature, does the period of production implies that there is some sort of infrastructure in the well area?\nIn this case, excluding observations with dates equal to 0, there are 1111 polygons where the production date is more recent than reclamation date, 18769 where the reclamation date is more recent than the production date, and 133 with both dates being the same.\n\n\nCode\na &lt;- abandoned_wells_df |&gt; \n        filter(reclamation_date != 0 & max_last_production_date != 0) |&gt; \n        mutate(diff = reclamation_date - max_last_production_date) |&gt; \n        select(diff, reclamation_date, max_last_production_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        # paged_table()\n        ggplot(aes(x = diff, y = n)) +\n        geom_col() +\n        theme_light()\n\nggplotly(a)\n\n\n\n\n\nFigure 5: Distribution of difference in years between reclamation and last production dates"
  },
  {
    "objectID": "abandoned_wells.html#abandoned-date-vs-last-production-date",
    "href": "abandoned_wells.html#abandoned-date-vs-last-production-date",
    "title": "Abandoned wells data exploration",
    "section": "Abandoned date vs Last Production date",
    "text": "Abandoned date vs Last Production date\n\n\nCode\ncat &lt;- abandoned_wells_df |&gt; \n        # filter(reclamation_date == 0) |&gt;\n        filter(max_abandoned_date != 0 & max_last_production_date != 0) |&gt;\n        mutate(diff = max_abandoned_date - max_last_production_date) |&gt; \n        select(diff, max_abandoned_date, max_last_production_date) |&gt; \n        # arrange(desc(diff))\n        # paged_table()\n        group_by(diff) |&gt; \n        tally() |&gt; \n        mutate(cat = case_when(\n                diff &lt; 0 ~ \"less\",\n                diff &gt; 0 ~ \"more\",\n                diff == 0 ~ \"same\",\n                .default = NA\n        )) |&gt; \n        group_by(cat) |&gt; \n        summarize(\n                total = sum(n)\n        )\n\n\nAbandoned date is sometimes zero, does this means it is still in production?\nThere is one variable feature_ty which definition is: “The type or category of human footprint feature”. In this dataset every observation has the category: “WELL-ABAND”, so all the polygons should be abandoned.\nWhen we have 0 in the abandoned date, we have:\n\n4687 observation with max last production date in 0.\nThe maximum date value in the range is 2022 (This is the maximum date value found for every date variable)\n\nAnd then, the distribution of the last production date observations that are not 0:\n\n\nCode\na &lt;- abandoned_wells_df |&gt; \n        filter(max_abandoned_date == 0) |&gt; \n        group_by(max_last_production_date) |&gt; \n        tally() |&gt; \n        filter(max_last_production_date != 0) |&gt; \n        ggplot(aes(x = max_last_production_date, y = n)) +\n        geom_bar(stat = \"identity\") +\n        theme_light()\n\nggplotly(a)\n\n\n\n\n\n\nIn this case, excluding observations with dates equal to 0, there are 779 polygons where the production date is more recent than abandoned date, 55022 where the abandoned date is more recent than the production date, and 7435 with both dates being the same.\n\n\n\n\n\n\nImportant\n\n\n\nDo we need to consider last production dates and abandoned dates to be earlier than the last reclamation date?"
  },
  {
    "objectID": "leaf_process.html",
    "href": "leaf_process.html",
    "title": "Process one site with LEAF-toolbox",
    "section": "",
    "text": "import ee\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport os\nimport sys"
  },
  {
    "objectID": "leaf_process.html#imports",
    "href": "leaf_process.html#imports",
    "title": "Process one site with LEAF-toolbox",
    "section": "",
    "text": "import ee\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport os\nimport sys"
  },
  {
    "objectID": "leaf_process.html#gee-authentication",
    "href": "leaf_process.html#gee-authentication",
    "title": "Process one site with LEAF-toolbox",
    "section": "GEE authentication",
    "text": "GEE authentication\n\nee.Authenticate()\nee.Initialize()\n\nTest if authentication was successful\n\nprint(ee.String('Hello from the Earth Engine servers!').getInfo())\n\nHello from the Earth Engine servers!"
  },
  {
    "objectID": "leaf_process.html#leaf-toolbox-imports",
    "href": "leaf_process.html#leaf-toolbox-imports",
    "title": "Process one site with LEAF-toolbox",
    "section": "LEAF-toolbox imports",
    "text": "LEAF-toolbox imports\nModules imports cannot be done before GEE authentication have been run succesfuly\n\n# Add the parent directory of leaftoolbox to the system path\nmodule_path = os.path.abspath(os.path.join('..'))\nif module_path not in sys.path:\n    sys.path.append(module_path)\n    \nfrom leaftoolbox import LEAF\nfrom leaftoolbox import SL2PV0 \nfrom leaftoolbox import SL2PV1\n\n/home/ronny/.local/share/virtualenvs/reclaimed_sites_ab-QXta-KJo/lib/python3.10/site-packages/ee/deprecation.py:202: DeprecationWarning:\n\n\n\nAttention required for JRC/GSW1_0/GlobalSurfaceWater! You are using a deprecated asset.\nTo ensure continued functionality, please update it.\nLearn more: https://developers.google.com/earth-engine/datasets/catalog/JRC_GSW1_0_GlobalSurfaceWater"
  },
  {
    "objectID": "notebooks/gee_filtering.html",
    "href": "notebooks/gee_filtering.html",
    "title": "GEE polygons filters",
    "section": "",
    "text": "Code\nimport ee\nimport geemap\nimport folium\nimport json\nAfter selecting the polygons from the abandoned wells, the following steps will continue with the filtering in GEE."
  },
  {
    "objectID": "notebooks/gee_filtering.html#create-buffers-in-reservoirs-polygons",
    "href": "notebooks/gee_filtering.html#create-buffers-in-reservoirs-polygons",
    "title": "GEE polygons filters",
    "section": "Create buffers in Reservoirs polygons",
    "text": "Create buffers in Reservoirs polygons\n\n\nCode\nasset_id = \"projects/ee-ronnyale/assets/reservoirs\"\nreservoirs = ee.FeatureCollection(asset_id)\n\n# Create function to buffer each feature by 30m\ndef buffer_feature(feature):\n  return feature.buffer(30)\n\n# Apply the buffer function to each of the reservoir polygons\nbuffered_reservoirs = reservoirs.map(buffer_feature)\n\n# Plot the buffers in the map\nreservoirs_map = geemap.Map(center=[53.516, -113.498], zoom=5)\nreservoirs_map.addLayer(reservoirs, {\"color\": \"blue\"}, \"reservoirs\")\nreservoirs_map.addLayer(buffered_reservoirs, {'color': '#75AADB'}, \"buffered_reservoirs\")\nreservoirs_map\n\n\n\n            \n            \n\n\n\n\n\n\nFind abandoned wells intersections with reservoirs\nManually, it seems that there is no abandoned well that intersects the reservoirs buffer areas. Nonetheles, we can check this with a function that records if there is an intersection or not. The following show the adding of the new two properties to the feature collection: intersection with the buffer and intersection with the reservoir polygon.\n\n\nCode\n# Function to find intersections between buffered polygons and waterbodies\ndef define_intersection(well):\n    intersects_reservoirs = reservoirs.filterBounds(well.geometry()).size().gt(0)\n    intersects_reservoirs_buffer = buffered_reservoirs.filterBounds(well.geometry()).size().gt(0)\n    return well.set('intersects_reservoirs', intersects_reservoirs) \\\n               .set('intersects_reservoirs_buffer', intersects_reservoirs_buffer)\n\n# Apply the intersection check to each well\nwells_with_intersections = abandoned_wells.map(define_intersection)\n\n# Show a sample\nsample = wells_with_intersections.limit(2).getInfo()\nprint(json.dumps(sample, indent = 2))\n\n\n\n            \n            \n\n\n{\n  \"type\": \"FeatureCollection\",\n  \"columns\": {\n    \"area_ha\": \"Float\",\n    \"disp_nm\": \"String\",\n    \"fetr_ty\": \"String\",\n    \"fieldnm\": \"String\",\n    \"frst_spd_d\": \"Long\",\n    \"frst_spd_y\": \"Integer\",\n    \"hfi_id\": \"String\",\n    \"intersects_reservoirs\": \"Number\",\n    \"intersects_reservoirs_buffer\": \"Number\",\n    \"lcu_id\": \"String\",\n    \"mn_npr_\": \"Integer\",\n    \"mx_bnd_\": \"Integer\",\n    \"mx_ls__\": \"Integer\",\n    \"nmbr_wl\": \"Integer\",\n    \"olsnd__\": \"Integer\",\n    \"plygn_s\": \"Integer\",\n    \"prd_x__\": \"Integer\",\n    \"rclmtn_c\": \"Integer\",\n    \"rclmtn_d\": \"Integer\",\n    \"rclmtn_s\": \"String\",\n    \"shape_r\": \"Float\",\n    \"shp_lng\": \"Float\",\n    \"source\": \"String\",\n    \"system:index\": \"String\",\n    \"visible\": \"Integer\",\n    \"wll_stt\": \"Integer\",\n    \"wllst__\": \"Integer\",\n    \"year\": \"Integer\"\n  },\n  \"version\": 1716336823537424,\n  \"id\": \"projects/ee-ronnyale/assets/selected_polygons\",\n  \"properties\": {\n    \"system:asset_size\": 20098598\n  },\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -115.17626384209883,\n              54.16848147380045\n            ],\n            [\n              -115.17453722252176,\n              54.16848399125569\n            ],\n            [\n              -115.17454141208857,\n              54.169497074721704\n            ],\n            [\n              -115.17626815168443,\n              54.16949462890382\n            ],\n            [\n              -115.17626384209883,\n              54.16848147380045\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000008c46\",\n      \"properties\": {\n        \"area_ha\": 1.272871342643425,\n        \"disp_nm\": \"\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 115200000,\n        \"frst_spd_y\": 1970,\n        \"hfi_id\": \"{72CFB218-1933-42A3-A396-FA16CF35DD7C}\",\n        \"intersects_reservoirs\": 0,\n        \"intersects_reservoirs_buffer\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1970,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"plygn_s\": 9,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 1974,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 12728.713426434248,\n        \"shp_lng\": 451.2863999977708,\n        \"source\": \"AHFMP\",\n        \"visible\": 0,\n        \"wll_stt\": 1,\n        \"wllst__\": 170504,\n        \"year\": 1970\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -111.6258150977823,\n              50.378640889095735\n            ],\n            [\n              -111.62438590584102,\n              50.37859936606693\n            ],\n            [\n              -111.62432064939453,\n              50.37951772649793\n            ],\n            [\n              -111.62574987513887,\n              50.37955925031751\n            ],\n            [\n              -111.6258150977823,\n              50.378640889095735\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000000fd0\",\n      \"properties\": {\n        \"area_ha\": 1.038418064780067,\n        \"disp_nm\": \"\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 201600000,\n        \"frst_spd_y\": 1970,\n        \"hfi_id\": \"{8F8D1B87-32C6-4D03-82E9-08F03963A67C}\",\n        \"intersects_reservoirs\": 0,\n        \"intersects_reservoirs_buffer\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1970,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"plygn_s\": 9,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 1992,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 10384.180647800671,\n        \"shp_lng\": 407.6111999992281,\n        \"source\": \"AHFMP\",\n        \"visible\": 2,\n        \"wll_stt\": 1,\n        \"wllst__\": 29104,\n        \"year\": 1970\n      }\n    }\n  ]\n}"
  },
  {
    "objectID": "notebooks/gee_filtering.html#waterbodies",
    "href": "notebooks/gee_filtering.html#waterbodies",
    "title": "GEE polygons filters",
    "section": "Waterbodies",
    "text": "Waterbodies\n\nCreate the waterbodies mask\nFrom all the features we have, I need juts the waterbodies. This is a raster which I also need to reduce to a vector to create the buffer area.\n\n\nCode\n# Water category is 1 (as seen in qgis)\nwater_mask = asset_image.eq(1)\nwater_image = asset_image.updateMask(water_mask)\n\n# Steps from raster to vector\nwater_bodies_vector = water_image.reduceToVectors(\n    geometryType=\"polygon\",\n    scale=10,  # LCC layer documentation states is 10m\n    maxPixels=1e8,\n    bestEffort=True,\n    labelProperty=\"water_bodies\",\n)\n\nwaterbodies_map = geemap.Map(center=[53.516, -113.498], zoom=5)\nwaterbodies_map.addLayer(water_bodies_vector, {\"color\": \"blue\"}, \"waterbodies_mask\")\nwaterbodies_map\n\n\n\n            \n            \n\n\n\n\n\nHow many waterbodies polygons do I have?\n\n\nCode\nprint(water_bodies_vector.size().getInfo())  # Number of water body polygons\n# print(water_bodies_vector.getInfo()) # Query exceeds the API limit\n\n# In case I need the resulting polygons\n# export_task = ee.batch.Export.table.toDrive(\n#     collection = water_bodies_vector,\n#     description = 'water_bodies_polygons',\n#     folder = 'earth_engine_exports',\n#     fileFormat = 'SHP'\n# )\n# export_task.start()\n# print(\"Export started. Check your Google Drive for the results.\")\n\n\n\n            \n            \n\n\n69018\n\n\n\n\nCreate buffers for waterbodies\nBased on the waterbodies resulting polygons, we are going to create a buffer area and then check if any of the abandoned well sites intersects them.\n\n\nCode\n# Function defined above in reservoirs section\nbuffered_waterbodies = water_bodies_vector.map(buffer_feature)\nwaterbodies_buffer_map = geemap.Map(center=[53.516, -113.498], zoom=5)\nwaterbodies_buffer_map.addLayer(\n    water_bodies_vector, {\"color\": \"blue\"}, \"waterbodies_mask\"\n)\nwaterbodies_buffer_map.addLayer(\n    buffered_waterbodies, {\"color\": \"#75AADB\"}, \"waterbodies_buffer\"\n)\nwaterbodies_buffer_map\n\n\n\n            \n            \n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nCheck that when creating the mask from the raster data, not all waterbodies match completely the waterbodies. This can be seen when zooming in the visualization.\n\n\n\n\nFind abandoned wells intersections with waterbodies\n\n\nCode\n# Function to check if a well intersects with waterbodies or buffered waterbodies\ndef define_intersection(well):\n    intersects_waterbody = water_bodies_vector.filterBounds(well.geometry()).size().gt(0)\n    intersects_buffer = buffered_waterbodies.filterBounds(well.geometry()).size().gt(0)\n    return well.set('intersects_waterbody', intersects_waterbody.toInt()) \\\n               .set('intersects_buffer', intersects_buffer.toInt())\n\n# Apply the intersection check to each well\nwells_with_intersections = abandoned_wells.map(define_intersection)\n\n# Show a sample\nsample = wells_with_intersections.limit(2).getInfo()\nprint(json.dumps(sample, indent = 2))\n\n\n\n            \n            \n\n\n{\n  \"type\": \"FeatureCollection\",\n  \"columns\": {\n    \"area_ha\": \"Float\",\n    \"disp_nm\": \"String\",\n    \"fetr_ty\": \"String\",\n    \"fieldnm\": \"String\",\n    \"frst_spd_d\": \"Long\",\n    \"frst_spd_y\": \"Integer\",\n    \"hfi_id\": \"String\",\n    \"intersects_buffer\": \"Number\",\n    \"intersects_waterbody\": \"Number\",\n    \"lcu_id\": \"String\",\n    \"mn_npr_\": \"Integer\",\n    \"mx_bnd_\": \"Integer\",\n    \"mx_ls__\": \"Integer\",\n    \"nmbr_wl\": \"Integer\",\n    \"olsnd__\": \"Integer\",\n    \"plygn_s\": \"Integer\",\n    \"prd_x__\": \"Integer\",\n    \"rclmtn_c\": \"Integer\",\n    \"rclmtn_d\": \"Integer\",\n    \"rclmtn_s\": \"String\",\n    \"shape_r\": \"Float\",\n    \"shp_lng\": \"Float\",\n    \"source\": \"String\",\n    \"system:index\": \"String\",\n    \"visible\": \"Integer\",\n    \"wll_stt\": \"Integer\",\n    \"wllst__\": \"Integer\",\n    \"year\": \"Integer\"\n  },\n  \"version\": 1716336823537424,\n  \"id\": \"projects/ee-ronnyale/assets/selected_polygons\",\n  \"properties\": {\n    \"system:asset_size\": 20098598\n  },\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -115.17626384209883,\n              54.16848147380045\n            ],\n            [\n              -115.17453722252176,\n              54.16848399125569\n            ],\n            [\n              -115.17454141208857,\n              54.169497074721704\n            ],\n            [\n              -115.17626815168443,\n              54.16949462890382\n            ],\n            [\n              -115.17626384209883,\n              54.16848147380045\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000008c46\",\n      \"properties\": {\n        \"area_ha\": 1.272871342643425,\n        \"disp_nm\": \"\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 115200000,\n        \"frst_spd_y\": 1970,\n        \"hfi_id\": \"{72CFB218-1933-42A3-A396-FA16CF35DD7C}\",\n        \"intersects_buffer\": 1,\n        \"intersects_waterbody\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1970,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"plygn_s\": 9,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 1974,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 12728.713426434248,\n        \"shp_lng\": 451.2863999977708,\n        \"source\": \"AHFMP\",\n        \"visible\": 0,\n        \"wll_stt\": 1,\n        \"wllst__\": 170504,\n        \"year\": 1970\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -111.6258150977823,\n              50.378640889095735\n            ],\n            [\n              -111.62438590584102,\n              50.37859936606693\n            ],\n            [\n              -111.62432064939453,\n              50.37951772649793\n            ],\n            [\n              -111.62574987513887,\n              50.37955925031751\n            ],\n            [\n              -111.6258150977823,\n              50.378640889095735\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000000fd0\",\n      \"properties\": {\n        \"area_ha\": 1.038418064780067,\n        \"disp_nm\": \"\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 201600000,\n        \"frst_spd_y\": 1970,\n        \"hfi_id\": \"{8F8D1B87-32C6-4D03-82E9-08F03963A67C}\",\n        \"intersects_buffer\": 0,\n        \"intersects_waterbody\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1970,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"plygn_s\": 9,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 1992,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 10384.180647800671,\n        \"shp_lng\": 407.6111999992281,\n        \"source\": \"AHFMP\",\n        \"visible\": 2,\n        \"wll_stt\": 1,\n        \"wllst__\": 29104,\n        \"year\": 1970\n      }\n    }\n  ]\n}"
  },
  {
    "objectID": "notebooks/gee_filtering.html#developed-area",
    "href": "notebooks/gee_filtering.html#developed-area",
    "title": "GEE polygons filters",
    "section": "Developed area",
    "text": "Developed area\n\nI will follow same process as waterbodies to create a mask (convert to vector) and then create the buffers\n\n\n\nCode\ndeveloped_mask = asset_image.eq(13)\ndeveloped_image = asset_image.updateMask(developed_mask)\n\ndeveloped_vector = developed_image.reduceToVectors(\n    geometryType=\"polygon\",\n    scale=10,\n    maxPixels=1e8,\n    bestEffort=True,\n    labelProperty=\"developed_areas\",\n)\n\nbuffered_developed_areas = developed_vector.map(buffer_feature)\n\ndeveloped_map = geemap.Map(center=[53.516, -113.498], zoom=5)\ndeveloped_map.addLayer(developed_vector, {\"color\": \"gray\"})\ndeveloped_map.addLayer(buffered_developed_areas, {\"color\": \"red\"})\ndeveloped_map\n\n# # Find intersections with developed areas\n# def define_intersection(well):\n#     intersects_developed_areas = developed_vector.filterBounds(well.geometry()).size().gt(0)\n#     intersects_buffer = buffered_developed_areas.filterBounds(well.geometry()).size().gt(0)\n#     return well.set('intersects_developed_areas', intersects_developed_areas.toInt()) \\\n#                .set('intersects_buffer_developed_areas', intersects_buffer.toInt())\n\n# # Apply the intersection check to each well\n# wells_with_intersections_developed_areas = abandoned_wells.map(define_intersection)\n\n# # Show a sample\n# sample = wells_with_intersections_developed_areas.limit(2).getInfo()\n# print(json.dumps(sample, indent = 2))\n\n\n\n            \n            \n\n\n\n\n\n\n\n\n\n\n\nImportant\n\n\n\nI didn’t use the developed_area category from the AER data that is a raster. Rather I used the ABMI data which is already a vector and contains the residential and industrial categories to create the buffers and check which abandoned wells intersect those."
  },
  {
    "objectID": "notebooks/gee_filtering.html#glimpse-of-the-flagged-feature-collection",
    "href": "notebooks/gee_filtering.html#glimpse-of-the-flagged-feature-collection",
    "title": "GEE polygons filters",
    "section": "Glimpse of the flagged feature collection",
    "text": "Glimpse of the flagged feature collection\nHere is a glimpse of the new properties created with the flagged intersections. Also, the number of abandoned wells polygons to be filter out.\n\n\nCode\nintersects_asset_id = \"projects/ee-ronnyale/assets/intersecting_wells_flags_v2\"\nintersects = ee.FeatureCollection(intersects_asset_id)\n\n# Get all polygons with an intersetion\nfilters = [\n    ee.Filter.eq(\"intersects_industrial\", 1),\n    ee.Filter.eq(\"intersects_industrial_buffer\", 1),\n    ee.Filter.eq(\"intersects_reservoirs\", 1),\n    ee.Filter.eq(\"intersects_reservoirs_buffer\", 1),\n    ee.Filter.eq(\"intersects_residential\", 1),\n    ee.Filter.eq(\"intersects_residential_buffer\", 1),\n    ee.Filter.eq(\"intersects_roads\", 1),\n    ee.Filter.eq(\"intersects_roads_buffer\", 1),\n    ee.Filter.eq(\"intersects_waterbodies\", 1),\n    ee.Filter.eq(\"intersects_waterbody_buffer\", 1),\n]\n\n# Combine the filters using ee.Filter.or\ncombined_filter = ee.Filter.Or(*filters)\n\n# Apply the combined filter to the feature collection\nintersecting_features = intersects.filter(combined_filter)\n\nsample = intersecting_features.limit(2).getInfo()\nprint(json.dumps(sample, indent=2))\nprint(intersecting_features.size().getInfo())\n\n\n\n            \n            \n\n\n{\n  \"type\": \"FeatureCollection\",\n  \"columns\": {\n    \"area_ha\": \"Float\",\n    \"disp_nm\": \"String\",\n    \"fetr_ty\": \"String\",\n    \"fieldnm\": \"String\",\n    \"frst_spd_d\": \"Long\",\n    \"frst_spd_y\": \"Integer\",\n    \"hfi_id\": \"String\",\n    \"intersects_industrial\": \"Long\",\n    \"intersects_industrial_buffer\": \"Long\",\n    \"intersects_reservoirs\": \"Long\",\n    \"intersects_reservoirs_buffer\": \"Long\",\n    \"intersects_residential\": \"Long\",\n    \"intersects_residential_buffer\": \"Long\",\n    \"intersects_roads\": \"Long\",\n    \"intersects_roads_buffer\": \"Long\",\n    \"intersects_waterbodies\": \"Long\",\n    \"intersects_waterbody_buffer\": \"Long\",\n    \"lcu_id\": \"String\",\n    \"mn_npr_\": \"Integer\",\n    \"mx_bnd_\": \"Integer\",\n    \"mx_ls__\": \"Integer\",\n    \"nmbr_wl\": \"Integer\",\n    \"olsnd__\": \"Integer\",\n    \"plygn_s\": \"Integer\",\n    \"prd_x__\": \"Integer\",\n    \"rclmtn_c\": \"Integer\",\n    \"rclmtn_d\": \"Integer\",\n    \"rclmtn_s\": \"String\",\n    \"shape_r\": \"Float\",\n    \"shp_lng\": \"Float\",\n    \"source\": \"String\",\n    \"system:index\": \"String\",\n    \"visible\": \"Integer\",\n    \"wll_stt\": \"Integer\",\n    \"wllst__\": \"Integer\",\n    \"year\": \"Integer\"\n  },\n  \"version\": 1716983263842881,\n  \"id\": \"projects/ee-ronnyale/assets/intersecting_wells_flags_v2\",\n  \"properties\": {\n    \"system:asset_size\": 20072004\n  },\n  \"features\": [\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -112.68162815068959,\n              51.05977825484342\n            ],\n            [\n              -112.68164020300942,\n              51.05897008678425\n            ],\n            [\n              -112.68054210325442,\n              51.058961704207235\n            ],\n            [\n              -112.68035777186363,\n              51.05896251896173\n            ],\n            [\n              -112.68034569219773,\n              51.05977068742345\n            ],\n            [\n              -112.68162815068959,\n              51.05977825484342\n            ]\n          ]\n        ]\n      },\n      \"id\": \"00000000000000000024\",\n      \"properties\": {\n        \"area_ha\": 0.810006630122344,\n        \"disp_nm\": \"MSL010842\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 985334400000,\n        \"frst_spd_y\": 2001,\n        \"hfi_id\": \"{1CA6D4B1-B26C-449E-BDF8-923813075B13}\",\n        \"intersects_industrial\": 0,\n        \"intersects_industrial_buffer\": 0,\n        \"intersects_reservoirs\": 0,\n        \"intersects_reservoirs_buffer\": 0,\n        \"intersects_residential\": 0,\n        \"intersects_residential_buffer\": 0,\n        \"intersects_roads\": 0,\n        \"intersects_roads_buffer\": 0,\n        \"intersects_waterbodies\": 1,\n        \"intersects_waterbody_buffer\": 1,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 2001,\n        \"mx_bnd_\": 2013,\n        \"mx_ls__\": 2012,\n        \"nmbr_wl\": 1,\n        \"olsnd__\": null,\n        \"plygn_s\": 1,\n        \"prd_x__\": 2,\n        \"rclmtn_c\": 3,\n        \"rclmtn_d\": 2016,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 8100.066301223439,\n        \"shp_lng\": 360.0012614489656,\n        \"source\": \"AHFMP\",\n        \"visible\": 2,\n        \"wll_stt\": 1,\n        \"wllst__\": 267653,\n        \"year\": 2001\n      }\n    },\n    {\n      \"type\": \"Feature\",\n      \"geometry\": {\n        \"type\": \"Polygon\",\n        \"coordinates\": [\n          [\n            [\n              -115.87584796786865,\n              54.55362614532342\n            ],\n            [\n              -115.875204692006,\n              54.552988137749416\n            ],\n            [\n              -115.87356385212406,\n              54.55273220383654\n            ],\n            [\n              -115.87319658902395,\n              54.553511442392335\n            ],\n            [\n              -115.87484522577167,\n              54.55377179362033\n            ],\n            [\n              -115.87491130596025,\n              54.553628468033594\n            ],\n            [\n              -115.87511654183191,\n              54.5531717727261\n            ],\n            [\n              -115.87557928040698,\n              54.55362806724955\n            ],\n            [\n              -115.87584796786865,\n              54.55362614532342\n            ]\n          ]\n        ]\n      },\n      \"id\": \"0000000000000000010b\",\n      \"properties\": {\n        \"area_ha\": 1.096115021944638,\n        \"disp_nm\": \"MSL991228\",\n        \"fetr_ty\": \"WELL-ABAND\",\n        \"fieldnm\": \"\",\n        \"frst_spd_d\": 939970800000,\n        \"frst_spd_y\": 1999,\n        \"hfi_id\": \"{058AFD84-5B2D-4A94-8602-6647A4E61E3E}\",\n        \"intersects_industrial\": 1,\n        \"intersects_industrial_buffer\": 1,\n        \"intersects_reservoirs\": 0,\n        \"intersects_reservoirs_buffer\": 0,\n        \"intersects_residential\": 0,\n        \"intersects_residential_buffer\": 0,\n        \"intersects_roads\": 0,\n        \"intersects_roads_buffer\": 0,\n        \"intersects_waterbodies\": 0,\n        \"intersects_waterbody_buffer\": 0,\n        \"lcu_id\": \"\",\n        \"mn_npr_\": 0,\n        \"mx_bnd_\": 1999,\n        \"mx_ls__\": 0,\n        \"nmbr_wl\": 1,\n        \"olsnd__\": null,\n        \"plygn_s\": 2,\n        \"prd_x__\": 1,\n        \"rclmtn_c\": 1,\n        \"rclmtn_d\": 2007,\n        \"rclmtn_s\": \"reclaimed\",\n        \"shape_r\": 10961.150219446377,\n        \"shp_lng\": 537.8595521247555,\n        \"source\": \"AHFMP\",\n        \"visible\": 2,\n        \"wll_stt\": 1,\n        \"wllst__\": 298532,\n        \"year\": 1999\n      }\n    }\n  ]\n}\n19639"
  },
  {
    "objectID": "notebooks/gee_filtering.html#visualization-of-intersecting-abandoned-wells",
    "href": "notebooks/gee_filtering.html#visualization-of-intersecting-abandoned-wells",
    "title": "GEE polygons filters",
    "section": "Visualization of intersecting abandoned wells",
    "text": "Visualization of intersecting abandoned wells\n\n\nCode\n# ABMI vector layers\nasset_flagged = \"projects/ee-ronnyale/assets/intersecting_wells_flags\"\nabandoned_wells = ee.FeatureCollection(asset_flagged)\n\n## Industrial ABMI\nasset_id = \"projects/ee-ronnyale/assets/industrial\"\nasset_industrial = ee.FeatureCollection(asset_id)\n\n## Residential ABMI\nasset_id = \"projects/ee-ronnyale/assets/residentials\"\nasset_residential = ee.FeatureCollection(asset_id)\n\n## Roads ABMI\nasset_id = \"projects/ee-ronnyale/assets/roads\"\nasset_roads = ee.FeatureCollection(asset_id)\n\n## Create buffer industrial-residential-roads\nbuffered_industrial = asset_industrial.map(buffer_feature)\nbuffered_residential = asset_residential.map(buffer_feature)\nbuffered_roads = asset_roads.map(buffer_feature)\n\n# Plot abandoned wells that intersect waterbodies\nwells_intersecting_map = geemap.Map(center=[53.516, -113.498], zoom=5)\n\n## Reservoirs\nwells_intersecting_map.addLayer(reservoirs, {\"color\": \"blue\"}, \"reservoirs\")\nwells_intersecting_map.addLayer(\n    buffered_reservoirs, {\"color\": \"#75AADB\"}, \"reservoirs_buffer\"\n)\n\n## Waterbodies\nwells_intersecting_map.addLayer(\n    water_bodies_vector, {\"color\": \"blue\"}, \"waterbodies_mask\"\n)\nwells_intersecting_map.addLayer(\n    buffered_waterbodies, {\"color\": \"#75AADB\"}, \"waterbodies_buffer\"\n)\n\n## Industrial\nwells_intersecting_map.addLayer(asset_industrial, {\"color\": \"#2B2D42\"}, \"industrial\")\nwells_intersecting_map.addLayer(\n    buffered_industrial, {\"color\": \"#8D99AE\"}, \"industrial_buffer\"\n)\n\n## Residential\nwells_intersecting_map.addLayer(asset_residential, {\"color\": \"#F77F00\"}, \"residential\")\nwells_intersecting_map.addLayer(\n    buffered_residential, {\"color\": \"#FCBF49\"}, \"residential_buffer\"\n)\n\n## Roads\nwells_intersecting_map.addLayer(asset_roads, {\"color\": \"#212529\"}, \"roads\")\nwells_intersecting_map.addLayer(buffered_roads, {\"color\": \"#343A40\"}, \"rodas_buffer\")\n\nwells_intersecting_map.addLayer(\n    intersecting_features, {\"color\": \"#FBFF12\"}, \"abandoned_wells\"\n)\nwells_intersecting_map"
  }
]